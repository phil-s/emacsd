;; Silence compiler warnings
(eval-when-compile
  (defvar compare-windows-get-window-function)
  (defvar dired-mode-map)
  (defvar find-grep-options)
  (defvar sql-buffer)
  (defvar sql-database)
  (defvar sql-product)
  (defvar sql-user)
  (defvar tags-loop-operate)
  (defvar tags-loop-scan)
  (defvar term-ansi-buffer-name)
  (defvar term-prompt-regexp)
  (defvar url-http-end-of-headers)
  (declare-function compare-windows-dehighlight "compare-w")
  (declare-function compare-windows-highlight "compare-w")
  (declare-function dired-add-file "dired-aux")
  (declare-function dired-create-directory "dired-aux")
  (declare-function dired-current-directory "dired")
  (declare-function dired-get-marked-files "dired")
  (declare-function dired-move-to-filename "dired")
  (declare-function he-substitute-string "hippie-exp")
  (declare-function ibuffer-quit "ibuffer")
  (declare-function shr-render-buffer "shr")
  (declare-function sql-buffer-live-p "sql")
  (declare-function sql-highlight-product "sql")
  (declare-function tramp-dissect-file-name "tramp")
  (declare-function tramp-file-name-host "tramp")
  (declare-function tramp-file-name-localname "tramp")
  (declare-function tramp-file-name-method "tramp")
  (declare-function tramp-file-name-port "tramp")
  (declare-function tramp-file-name-user "tramp")
  (declare-function tramp-get-completion-function "tramp")
  (declare-function tramp-tramp-file-p "tramp")
  (declare-function winner-redo "winner")
  (declare-function winner-undo "winner")
  )

;; (defun my-ido-filename ()
;;   "Return the filename selected with ido."
;;   (interactive)
;;   (flet ((ido-visit-buffer (filename &rest) filename)
;;          (find-file-noselect (filename &rest) filename))
;;     (let ((filename (ido-file-internal nil)))
;;       (message filename)
;;       filename)))

(defun set-region-read-only (begin end)
  "Sets the read-only text property on the marked region.

Use `set-region-writeable' to remove this property."
  ;; See http://stackoverflow.com/questions/7410125
  (interactive "r")
  (with-silent-modifications
    (add-text-properties begin end '(read-only t))))

(defun set-region-writeable (begin end)
  "Removes the read-only text property from the marked region.

Use `set-region-read-only' to set this property."
  ;; See http://stackoverflow.com/questions/7410125
  (interactive "r")
  (with-silent-modifications
    (remove-text-properties begin end '(read-only t))))

(eval-when-compile
  (defvar he-num)
  (defvar he-search-string)
  (defvar he-tried-table)
  (declare-function he-substitute-string "hippie-exp"))

(defun my-hippie-expand-completions (&optional hippie-expand-function)
  "Return the full list of possible completions generated by `hippie-expand'.
The optional argument can be generated with `make-hippie-expand-function'."
  (require 'cl)
  (let ((this-command 'my-hippie-expand-completions)
        (last-command last-command)
        (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
    ;; avoid the (ding) when hippie-expand exhausts its options.
    (cl-letf (((symbol-function 'ding) 'ignore))
      ;; Evaluating the completions modifies the buffer, however we
      ;; will finish up in the same state that we began.
      (with-silent-modifications
        (while (progn
                 (funcall hippie-expand-function nil)
                 (setq last-command 'my-hippie-expand-completions)
                 (not (equal he-num -1))))))
    ;; Provide the options in the order in which they are normally generated.
    (delete he-search-string (reverse he-tried-table))))

(declare-function he-substitute-string "hippie-exp" (STR &optional TRANS-CASE))
(defmacro my-ido-hippie-expand-with (hippie-expand-function)
  "Generate an interactively-callable function that offers ido-based completion
using the specified hippie-expand function."
  `(lambda (&optional selection)
     (interactive
      (let ((options (my-hippie-expand-completions ,hippie-expand-function)))
        (when options
          (list (ido-completing-read "Completions: " options)))))
     (if selection
         (progn
           (undo-boundary)
           (he-substitute-string selection t))
       (message "No expansion found"))))

(defun my-ido-hippie-expand ()
  "Offer ido-based completion for the word at point."
  (interactive)
  (call-interactively (my-ido-hippie-expand-with 'hippie-expand)))

(defun my-ido-hippie-expand-filename ()
  "Offer ido-based completion for the filename at point."
  (interactive)
  (call-interactively
   (my-ido-hippie-expand-with
    (make-hippie-expand-function '(try-complete-file-name)))))

;; Functions/keys for moving within and switching between
;; buffers and windows

(defun expand-other-window ()
  "Move to and expand the next window"
  (interactive)
  (other-window 1)
  (delete-other-windows))


;; @see https://gist.github.com/1415844
(defun my-rotate-left (l) (append (cdr l) (list (car l))))
(defun my-rotate-windows ()
  (let ((start-positions (my-rotate-left (mapcar 'window-start (window-list))))
        (buffers (my-rotate-left (mapcar 'window-buffer (window-list)))))
    (cl-mapcar (lambda (window buffer pos)
                 (set-window-buffer window buffer)
                 (set-window-start window pos))
               (window-list)
               buffers
               start-positions)))

(defun kill-other-buffer ()
  "Kill the next buffer, and expand the current one"
  (interactive)
  (other-window 1)
  (kill-buffer nil)
  (other-window -1)
  (delete-other-windows))

(defun split-window-vertically-change-buffer ()
  "Split the window vertically, and switch to the next buffer"
  (interactive)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer (other-buffer)))

(defun my-other-frame (arg)
  "If there is no other-frame, ring the bell."
  (interactive "p")
  (if (eq (next-frame (selected-frame)) (selected-frame))
      (ding)
    (other-frame arg)))

(defun my-align-next-window ()
  "Move point in `next-window' to the same line as the current window."
  (interactive)
  (recenter)
  (let ((line (line-number-at-pos)))
    (with-selected-window (next-window)
      (recenter)
      (goto-char (point-min))
      (forward-line (1- line)))))

(defun my-scroll-one-line-ahead ()
  "Scroll ahead one line"
  (interactive)
  (scroll-up 1)
  (forward-line 1))

(defun my-scroll-one-line-back ()
  "Scroll back one line"
  (interactive)
  (scroll-down 1)
  (forward-line -1))

(defun my-transient-repeat-map ()
  "Cause the last command key to repeat the current command."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map last-command-event this-command))))

(defun my-scroll-one-line-transient-repeat-map ()
  "Cause the last command key to repeat the current command."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "n") #'my-scroll-one-line-ahead-repeatable)
     (define-key map (kbd "p") #'my-scroll-one-line-back-repeatable)
     (define-key map (kbd "SPC") #'ignore)
     map)))

(defun my-scroll-one-line-ahead-repeatable ()
  "Scroll ahead one line; repeat with last command key."
  (interactive)
  (my-scroll-one-line-ahead)
  (my-scroll-one-line-transient-repeat-map))

(defun my-scroll-one-line-back-repeatable ()
  "Scroll back one line; repeat with last command key."
  (interactive)
  (my-scroll-one-line-back)
  (my-scroll-one-line-transient-repeat-map))

;; (defun my-multi-occur-in-matching-buffers (regexp &optional allbufs)
;;   "Show all lines matching REGEXP in all buffers.
;; Enhance this to ignore other known-bad files?
;; http://stackoverflow.com/questions/2641211/emacs-interactively-search-open-buffers/2642655#2642655

;; TODO: Re-write to *positively* match and delete bad buffer names from
;; the list of all buffers, and pass the resulting list into `multi-occur',
;; instead of using `multi-occur-in-matching-buffers'.
;; "
;;   (interactive (occur-read-primary-args))
;;   (let* ((not-tags "\\([^T]\\|T[^A]\\|TA[^G]\\|TAG[^S]\\|TAGS.\\)")
;;          (exclude-tags-pattern (if allbufs
;;                                    (concat "^" not-tags)
;;                                  (concat "/" not-tags "[^/]*$"))))
;;     (multi-occur-in-matching-buffers
;;      exclude-tags-pattern
;;      regexp)))

(defvar my-multi-occur-buffers-file-name-exclusions '("TAGS")
  "List of file names to exclude from my-multi-occur,
ignoring the directory path.")

(defvar my-multi-occur-buffers-file-path-exclusions nil
  "List of file paths to exclude from my-multi-occur.")

(defun my-multi-occur-buffers (&optional non-file-buffers)
  "List of file-visiting buffers, excluding any known unwanted buffers."
  (let* ((list (buffer-list))
         (buffers list))
    (while buffers
      (let* ((buffer (car buffers))
             (next (cdr buffers))
             (buffer-name (buffer-name buffer))
             (file-name (buffer-file-name buffer))
             (file-name-exclusions my-multi-occur-buffers-file-name-exclusions))
        ;; Exclude non-file and internal-use buffers.
        (when (or (string= (substring buffer-name 0 1) " ") ;; internal
                  (not (or file-name non-file-buffers))
                  (and file-name
                       (or (member file-name file-name-exclusions)
                           (member (file-name-nondirectory file-name)
                                   file-name-exclusions))))
          (setq list (delq buffer list)))
        (setq buffers next)))
    list))

(defun my-multi-occur (regexp &optional nlines)
  "Show lines matching REGEXP in all file-visiting buffers.
With raw prefix arg C-u also include non-file buffers, otherwise
any numeric prefix argument is passed to `occur' as nlines."
  (interactive
   (if (consp current-prefix-arg)
       (list (car (occur-read-primary-args)) 'non-file-buffers)
     (occur-read-primary-args)))
  (if (eq nlines 'non-file-buffers)
      (multi-occur (my-multi-occur-buffers t) regexp)
    (multi-occur (my-multi-occur-buffers) regexp nlines)))

(defun my-multi-occur-in-visible-buffers (regexp &optional arg)
  "Show all lines matching REGEXP in the current frame's visible buffers."
  (interactive (occur-read-primary-args)) ;; optional arg required but ignored
  (let ((visible-buffers nil))
    (walk-windows (lambda (window)
                    (add-to-list 'visible-buffers (window-buffer window))))
    (multi-occur visible-buffers regexp)))

(eval-when-compile
  (declare-function term-send-raw-string "term" (chars))
  (declare-function term-mode "term" ())
  (declare-function term-char-mode "term" ())
  (require 'term) ;; `term-in-char-mode' is a macro.
  )
(defun my-forward-word-or-buffer-or-windows (&optional arg)
  "Enable <C-left> to call `next-buffer' if the last command was
`next-buffer' or `previous-buffer', and `winner-redo' if the last
command was `winner-undo' or `winner-redo'."
  (interactive "p")
  (cond ((memq last-command (list 'next-buffer 'previous-buffer))
         (progn (next-buffer)
                (setq this-command 'next-buffer)))
        ((memq last-command (list 'winner-redo 'winner-undo))
         (progn (winner-redo)
                (setq this-command 'winner-redo)))
        ((and (derived-mode-p 'term-mode)
              (require 'term)      ; for byte-compilation
              (term-in-char-mode)) ; <- macro expansion
         (term-send-raw-string "f"))
        (t ;else
         (progn (forward-word arg)
                (setq this-command 'forward-word)))))

(defun my-backward-word-or-buffer-or-windows (&optional arg)
  "Enable <C-left> to call `previous-buffer' if the last command was
`next-buffer' or `previous-buffer', and `winner-undo' if the last
command was `winner-undo' or `winner-redo'."
  (interactive "p")
  (cond ((memq last-command (list 'next-buffer 'previous-buffer))
         (progn (previous-buffer)
                (setq this-command 'previous-buffer)))
        ((memq last-command (list 'winner-redo 'winner-undo))
         (progn (winner-undo)
                (setq this-command 'winner-undo)))
        ((and (derived-mode-p 'term-mode)
              (require 'term)      ; for byte-compilation
              (term-in-char-mode)) ; <- macro expansion
         (term-send-raw-string "b"))
        (t ;else
         (progn (backward-word arg)
                (setq this-command 'backward-word)))))

;; Provide a simpler backwards zap-to-char (than prefixing with C-u -1)
(defun zap-to-char-backwards (arg char)
  (interactive "p\ncZap backwards to char: ")
  (zap-to-char (- arg) char))

;; Enable apply-macro-to-region-lines with named macros
(defun apply-named-macro-to-region-lines (top bottom)
  "Apply named keyboard macro to all lines in the region."
  (interactive "r")
  (let ((macro (intern
                (completing-read "kbd macro (name): "
                                 obarray
                                 (lambda (elt)
                                   (and (fboundp elt)
                                        (or (stringp (symbol-function elt))
                                            (vectorp (symbol-function elt))
                                            (get elt 'kmacro))))
                                 t))))
    (apply-macro-to-region-lines top bottom macro)))

;; Uniqify region (alternative to "C-u M-| uniq RET")
(defun uniquify-region ()
  "remove duplicate adjacent lines in the given region"
  (interactive)
  (narrow-to-region (region-beginning) (region-end))
  (goto-char (point-min))
  (while (re-search-forward "\\(.*\n\\)\\1+" nil t)
    (replace-match "\\1" nil nil))
  (widen)
  nil)

;; Uniqify region (alternative to "C-u M-| sort | uniq RET")
(defun uniquify-region-sorted ()
  "sort and remove duplicate lines in the given region"
  (interactive)
  (sort-lines nil (region-beginning) (region-end))
  (uniquify-region))

;; Rename file and buffer together
(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file name new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

;; Duplicate / clone the current line.
(defun clone-line (&optional arg)
  "Duplicate the line at point (arg times)."
  (interactive "*p")
  (save-excursion
    ;; The last line of the buffer cannot be killed
    ;; if it is empty. Instead, simply add a new line.
    (if (and (eobp) (bolp))
        (newline)
      ;; Otherwise kill the whole line, and yank it back.
      (let ((kill-read-only-ok t)
            deactivate-mark)
        (setq buffer-read-only t)
        (kill-whole-line)
        (setq buffer-read-only nil)
        (while (> arg 0)
          (yank)
          (setq arg (1- arg)))))))

;; Toggle between BOL and beginning of code
(defun my-beginning-of-line-or-indentation ()
  "Move to beginning of line, or indentation."
  (interactive)
  (if (bolp)
      (back-to-indentation)
    (beginning-of-line)))

(defun my-indent-rigidly (beginning end &optional arg)
  "Indent current line or active region ARG columns, using `indent-rigidly'.

If no argument is supplied, indent by `tab-width' columns."
  (interactive "r\nP")
  (unless (region-active-p)
    (setq beginning (line-beginning-position)
          end (line-end-position)))
  (indent-rigidly beginning end (if arg
                                    (prefix-numeric-value arg)
                                  tab-width)))

(defun my-capitalize-word (&optional arg)
  "Used to invoke capitalize-word despite subword-mode remappings."
  (interactive "*p")
  (capitalize-word arg))

;; Display non-critical messages with minimal interference.
(defun my-unimportant-notification (format-string &rest args)
  "Display a message temporarily, if/when minibuffer isn't active.
Also see the following:
`minibuffer-message'
`with-temp-message'
`minibuffer-message-timeout'"
  (my--unimportant-notification
   format-string args
   6 ;; seed the remaining attempts counter (maximum)
   5 ;; number of seconds to increase delay by when minibuffer is active
   ))

(defun my--unimportant-notification
  (format-string args attempts increment &optional delay total)
  "Private logic for \\[my-unimportant-notification]"
  (let ((delay (or delay 0))
        (total (or total 0)))
    (if (and (eq (selected-window) (minibuffer-window))
             (> attempts 0))   ; ^^ or: (minibufferp (current-buffer)) ?
                               ; and: (not cursor-in-echo-area) ?
                               ; see: (eldoc-display-message-no-interference-p)

        ;; if the minibuffer is active, then postpone the message by an
        ;; ever-increasing delay, until we exceed our available attempt
        ;; limit (at which point we display the message regardless).
        (let* ((delay (+ increment delay))
               (total (+ total delay)))
          (run-with-timer
           delay nil
           'my--unimportant-notification
           format-string args (1- attempts) increment delay total))
      ;; otherwise show the message
      (let* ((backup-message (current-message))
             (delay-message " (message delayed %d seconds)")
             (delay-arg (or (and (zerop total) "")
                            (format delay-message total)))
             (args (append args (list delay-arg) nil))
             (format-string (concat format-string "%s"))
             (tmp-message (apply 'format format-string args)))
        ;; show message briefly, then revert.
        (message tmp-message)
        (run-with-timer
         3 nil
         (lambda (tmp-message backup-message)
           ;; revert to the backup message, unless something
           ;; else has already over-written our temporary one
           (when (string= tmp-message (current-message))
             (message backup-message)))
         tmp-message
         backup-message)))))

(defun reminder (what when)
  "Remind me about something later."
  (interactive "sRemind me about: \nsRemind me at: ")
  (let ((buf (get-buffer-create " *reminder*")))
    (with-current-buffer buf
      (erase-buffer))
    (shell-command
     (format "echo 'DISPLAY=:0.0 zenity --info --title=\"Reminder\" --text=%s' \
| at -M %s 2>&1 | grep -v \"warning: commands will be executed using /bin/sh\""
             (shell-quote-argument what)
             (shell-quote-argument when))
     buf " *reminder-errors*")))

(defun my-interactive-ding ()
  (interactive)
  (ding))

;; Convert file's EOL style to Unix
(defun to-unix-eol (fpath)
  "Change file's line ending to unix convention."
  (let (mybuffer)
    (setq mybuffer (find-file fpath))
    (set-buffer-file-coding-system 'unix) ; or 'mac or 'dos
    (save-buffer)
    (kill-buffer mybuffer)))

;; Bulk-convert EOL style to Unix (for marked files in Dired).
(defun dired-2unix-marked-files ()
  "Change to unix line ending for marked (or next arg) files."
  (interactive)
  (mapc 'to-unix-eol (dired-get-marked-files)))

;; pop-to-mark-command in the opposite direction
;; around the local mark-ring
(defun unpop-to-mark-command ()
  "Unpop off mark ring into the buffer's actual mark.
Does not set point.  Does nothing if mark ring is empty."
  (interactive)
  (let ((num-times
         (if (equal last-command 'pop-to-mark-command) 2 1
           ;; (if (equal last-command 'unpop-to-mark-command) 1
           ;;   (error "Previous command was not a (un)pop-to-mark-command"))
           )))
    (dotimes (x num-times)
      (when mark-ring
        (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
        (set-marker (mark-marker) (+ 0 (car (last mark-ring))) (current-buffer))
        (when (null (mark t)) (ding))
        (setq mark-ring (nbutlast mark-ring))
        (goto-char (mark t)))
      (deactivate-mark))))

(defmacro activate-my-unpop-to-mark-advice ()
  "Enable reversing direction with un/pop-to-mark."
  `(defadvice ,(key-binding (kbd "C-SPC"))
     (around my-unpop-to-mark-advice activate)
     "Unpop-to-mark with negative arg"
     (let* ((arg (ad-get-arg 0))
            (num (prefix-numeric-value arg)))
       (cond
        ;; Enabled repeated un-pops with C-SPC
        ((eq last-command 'unpop-to-mark-command)
         (if (and arg (> num 0) (<= num 4))
             ad-do-it ;; C-u C-SPC reverses back to normal direction
           ;; Otherwise continue to un-pop
           (setq this-command 'unpop-to-mark-command)
           (unpop-to-mark-command)))
        ;; Negative argument un-pops: C-- C-SPC
        ((< num 0)
         (setq this-command 'unpop-to-mark-command)
         (unpop-to-mark-command))
        (t
         ad-do-it)))))
(activate-my-unpop-to-mark-advice)

;; Kill ring / Yank assistance
(defun my-yank-menu ()
  "Select text to yank from a pop-up menu of recently killed items."
  (interactive)
  (popup-menu 'yank-menu))

(when (require 'browse-kill-ring nil 'noerror)
  ;; Either...
  ;; make it the default behaviour:
  ;;(browse-kill-ring-default-keybindings)
  ;;
  ;; or use a custom key binding:
  (global-set-key (kbd "C-c k") 'browse-kill-ring)
  )

;; Make M-y re-yank the most-recently-yanked text if the previous
;; command was NOT a yank. This prevents the gradual burying of the
;; desired text in the kill ring, when you wish to kill several
;; pieces of text, but yank the same thing in as a replacement.
;; @see; http://stackoverflow.com/a/5825012/324105
(defun jp/yank (&optional arg)
  "Yank and save text to jp/yank register"
  (interactive)
  (set-register 'jp/yank (current-kill 0 t))
  (yank arg))

(defun jp/yank-pop (&optional arg)
  "If yank-pop fails, insert jp/yank register contents instead."
  (interactive)
  (condition-case nil
      (yank-pop arg)
    (error (insert (get-register 'jp/yank)))))

;; Write a copy of the current buffer or region to a file.
(defun my-write-copy-to-file ()
  "Write a copy of the current buffer or region to a file."
  (interactive)
  (let* ((curr (buffer-file-name))
         (new (read-file-name
               "Copy to file: " nil nil nil
               (and curr (file-name-nondirectory curr))))
         (mustbenew (if (and curr (file-equal-p new curr)) 'excl t)))
    (if (use-region-p)
        (write-region (region-beginning) (region-end) new nil nil nil mustbenew)
      (save-restriction
        (widen)
        (write-region (point-min) (point-max) new nil nil nil mustbenew)))))

;; Grab copy of the current buffer's filename.
(defun my-copy-buffer-file-name (&optional arg)
  "Copy the buffer's filename to the kill ring.
With a prefix arg, use the file's truename."
  (interactive "P")
  (let ((filename (if arg
                      (file-truename (buffer-file-name))
                    (buffer-file-name))))
    (if (not filename)
        (message "No buffer filename")
      (message filename)
      (kill-new filename))))

(defun my-dired-jump (arg)
  "Like `dired-jump', but a single (C-u) prefix arg means \"replace the
current buffer with the target dired buffer\" (i.e. kill the original
buffer). A double (C-u C-u) prefix argument triggers the normal prefix
argument behaviour of `dired-jump'."
  (interactive "P")
  (require 'dired-x)
  (cond
   ((equal arg '(4))
    (let ((origin (current-buffer))
          (current-prefix-arg nil))
      (call-interactively 'dired-jump)
      (kill-buffer origin)))
   ((equal arg '(16))
    (let ((current-prefix-arg '(4)))
      (call-interactively 'dired-jump)))
   (t
    (call-interactively 'dired-jump))))

(defun my-parent-of-dir-in-buffer-file-name (dir)
  "Return the path to the parent of the named directory (arg),
within the current buffer-file-name."
  (let* ((bfn-list (split-string (buffer-file-name) "/"))
         (dir-list (reverse (cdr (member dir (reverse bfn-list))))))
    (when dir-list
      (mapconcat 'identity dir-list "/"))))

(defun my-directory-files (directory &optional full match nosort)
  "Like `directory-files', but excluding \".\" and \"..\"."
  (let ((files (cons nil (directory-files directory full match nosort))))
    (let ((parent files)
          (current (cdr files))
          (exclude (list "." ".."))
          (file nil))
      (while (and current exclude)
        (setq file (car current))
        (if (not (member file exclude))
            (setq parent current)
          (setcdr parent (cdr current))
          (setq exclude (delete file exclude)))
        (setq current (cdr current)))
      (cdr files))))

(defun my-before-save-create-directory-maybe ()
  "Offer to create the file's parent directories, if they do not exist."
  (let ((dir (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p dir))
               (y-or-n-p (format "Directory %s does not exist. Create it? " dir)))
      (make-directory dir t))))

;; Add a 'F'ind marked files keybinding to dired
(eval-after-load "dired"
  '(progn
     ;; my-dired-find-file
     (define-key dired-mode-map (kbd "F") 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))

     ;; my-dired-create-file
     (define-key dired-mode-map (kbd "_") 'my-dired-create-file)
     (defun my-dired-create-file (file)
       "Create a file called FILE.
    If FILE already exists, signal an error."
       (interactive
        (list (read-file-name "Create file: " (dired-current-directory))))
       (let* ((expanded (expand-file-name file))
              (try expanded)
              (dir (directory-file-name (file-name-directory expanded)))
              new)
         (if (file-exists-p expanded)
             (error "Cannot create file %s: file exists" expanded))
         ;; Find the topmost nonexistent parent dir (variable `new')
         (while (and try (not (file-exists-p try)) (not (equal new try)))
           (setq new try
                 try (directory-file-name (file-name-directory try))))
         (when (not (file-exists-p dir))
           (make-directory dir t))
         (write-region "" nil expanded t)
         (when new
           (dired-add-file new)
           (dired-move-to-filename))))
     )) ;; end of eval-after-load "dired"

(defun my-find-iname-grep-dired (dir pattern regexp)
  "`find-grep-dired' with additional file-name pattern argument."
  (interactive
   "DFind-name (directory): \nsFind-name (filename wildcard): \nsFind-grep (grep regexp): ")
  (find-dired dir (concat "-iname " (shell-quote-argument pattern) " "
                          "-type f -exec " grep-program " " find-grep-options " -e "
                          (shell-quote-argument regexp) " "
                          (shell-quote-argument "{}") " "
                          (shell-quote-argument ";"))))

(defvar my-shell-command-to-dired-history '("ls -al"))
(defun my-shell-command-to-dired (cmd)
  "Invoke `dired-virtual-mode' on the output of shell command CMD.

The shell command's output format must be equivalent to that of \"ls -al\"."
  (interactive
   (list (read-from-minibuffer
          (format "Shell command (%s): "
                  (car my-shell-command-to-dired-history))
          nil nil nil 'my-shell-command-to-dired-history)))
  (when (string= "" cmd)
    (setq cmd (or (car my-shell-command-to-dired-history)
                  "ls -al")))
  (let ((buf (get-buffer-create (format "*Dired: %S*" cmd))))
    (shell-command cmd buf)
    (with-current-buffer buf
      (dired-virtual-mode)
      (pop-to-buffer buf))))


;; Add a non-regexp `dired-do-query-replace-regexp' equivalent.
(eval-after-load 'dired
  '(define-key dired-mode-map (kbd "C-c Q") 'my-dired-do-query-replace))

(defun my-dired-do-query-replace (from to &optional delimited)
  "Do `query-replace' of FROM with TO, on all marked files.
Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit (\\[keyboard-quit], RET or q), you can resume the query replace
with the command \\[tags-loop-continue]."
  (interactive
   (let ((common
          (query-replace-read-args
           "Query replace in marked files" nil t)))
     (list (nth 0 common) (nth 1 common) (nth 2 common))))
  (require 'dired-aux)
  (dolist (file (dired-get-marked-files nil nil 'dired-nondirectory-p))
    (let ((buf (get-file-buffer file)))
      (if (and buf (buffer-local-value 'buffer-read-only buf))
          (error "File `%s' is visited read-only" file))))
  (my-tags-query-replace
   from to delimited '(dired-get-marked-files nil nil 'dired-nondirectory-p)))

(defun my-tags-query-replace (from to &optional delimited file-list-form)
  "Do `query-replace' of FROM with TO on all files listed in tags table.
Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit (\\[keyboard-quit], RET or q), you can resume the query replace
with the command \\[tags-loop-continue].
Fourth arg FILE-LIST-FORM non-nil means initialize the replacement loop.
Fifth and sixth arguments START and END are accepted, for compatibility
with `query-replace', and ignored.

If FILE-LIST-FORM is non-nil, it is a form to evaluate to
produce the list of files to search.

See also the documentation of the variable `tags-file-name'."
  (interactive (query-replace-read-args "Tags query replace" nil t))
  (require 'etags)
  (setq tags-loop-scan `(let ,(unless (equal from (downcase from))
                                '((case-fold-search nil)))
                          (if (search-forward ',from nil t)
                              ;; When we find a match, move back
                              ;; to the beginning of it so perform-replace
                              ;; will see it.
                              (goto-char (match-beginning 0))))
        tags-loop-operate `(perform-replace ',from ',to t nil ',delimited
                                            nil multi-query-replace-map))
  (tags-loop-continue (or file-list-form t)))

(defun my-replace-regexp-group (from to group)
  "In all matches for regexp FROM, replace the content of GROUP with TO."
  (interactive "sFrom: \nsTo: \nnGroup: ")
  (while (re-search-forward from nil t)
    (replace-match to nil nil nil group)))

;; Toggle between a vertical and horizontal window split
(defun toggle-window-split ()
  (interactive)
  (when (= (count-windows) 2)
    (let* ((this-win-buffer (window-buffer))
           (next-win-buffer (window-buffer (next-window)))
           (this-win-edges (window-edges (selected-window)))
           (next-win-edges (window-edges (next-window)))
           (this-win-2nd (not (and (<= (car this-win-edges)
                                       (car next-win-edges))
                                   (<= (cadr this-win-edges)
                                       (cadr next-win-edges)))))
           (splitter
            (if (= (car this-win-edges)
                   (car (window-edges (next-window))))
                'split-window-horizontally
              'split-window-vertically)))
      (delete-other-windows)
      (let ((first-win (selected-window)))
        (funcall splitter)
        (when this-win-2nd (other-window 1))
        (set-window-buffer (selected-window) this-win-buffer)
        (set-window-buffer (next-window) next-win-buffer)
        (select-window first-win)
        (when this-win-2nd (other-window 1))))))

(defun my-split-window-below (&optional arg)
  "Split the current window 50/50 by default.
A single-digit prefix argument gives the top window arg * 10%
of the available lines."
  (interactive "P")
  (let* ((proportion (and arg (* arg 0.1)))
         (size (and proportion (round (* proportion (window-height))))))
    (split-window-below size)))

;; Toggle window dedication
(defun toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message (if (let* ((window (selected-window))
                      (toggle (not (window-dedicated-p window))))
                 (set-window-dedicated-p window toggle))
               "Window '%s' is dedicated"
             "Window '%s' is normal")
           (current-buffer)))

;;
;; Ediff the current buffer's file with its auto-saved backup file.
;;
(defun ediff-auto-save ()
  "Compare the current buffer's file with its auto-saved backup file."
  (interactive)
  (let ((auto-file-name (make-auto-save-file-name))
        (file-major-mode major-mode))
    (ediff-files buffer-file-name auto-file-name)
    (switch-to-buffer-other-window (file-name-nondirectory auto-file-name))
    (apply file-major-mode '())
    (other-window 1))) ;; back to ediff panel

;;
;; Diff the current buffer with the file contents
;;
(defun my-diff-buffer-with-file ()
  "Compare the current modified buffer with the saved version."
  (interactive)
  (let ((diff-switches "-u")) ;; unified diff
    (diff-buffer-with-file (current-buffer))))

;;(defun ediff-file-with-buffer (file-A buf-B &optional startup-hooks job-name merge-buffer-file)
;;  (let (buf-A buf-C)
;;    (message "Reading file %s ... " file-A)
;;    ;;(sit-for 0)
;;    (ediff-find-file 'file-A 'buf-A 'ediff-last-dir-A 'startup-hooks)
;;    (ediff-setup buf-B file-B
;;       startup-hooks
;;       (list (cons 'ediff-job-name job-name))
;;       merge-buffer-file)))
;;
;; see defun ediff-setup (ediff-utils.el)
;; see defun ediff-files-internal (ediff.el)


;; By default, `ediff' is an alias for `ediff-files' in `ediff.el'.
(defalias 'ediff 'my-ediff-dwim)
(defun my-ediff-dwim ()
  "Do what I mean, when invoking `ediff'.

If a region is active when this command is called, call `ediff-regions-wordwise'.

Else if the current frame has 2 windows,
- Do `ediff-files' if the buffers are associated to files and the buffers
  have not been modified.
- Do `ediff-buffers' for the two buffers, otherwise.

Otherwise call `ediff-buffers' interactively."
  ;; Adapted from: http://kaushalmodi.github.io/2015/03/09/do-ediff-as-i-mean/
  (interactive)
  (if (region-active-p)
      (call-interactively 'ediff-regions-wordwise)
    (if (= 2 (safe-length (window-list)))
        (let* ((bufa (get-buffer (buffer-name)))
               (filea (buffer-file-name bufa))
               (bufb (save-excursion
                       (other-window 1)
                       (get-buffer (buffer-name))))
               (fileb (buffer-file-name bufb)))
          (if (or
               ;; if either of the buffers is not associated to a file
               (null filea) (null fileb)
               ;; if either of the buffers is modified
               (buffer-modified-p bufa) (buffer-modified-p bufb))
              (progn
                (message "Running (ediff-buffers \"%s\" \"%s\") .." bufa bufb)
                (ediff-buffers bufa bufb))
            (progn
              (message "Running (ediff-files \"%s\" \"%s\") .." filea fileb)
              (ediff-files filea fileb))))
      (call-interactively 'ediff-buffers))))

(defun my-compare-windows-complete (&optional ignore-whitespace)
  "Highlight all differences between two windows.

With a prefix argument, do not highlight whitespace-only differences.
\(This does not prevent the highlighting of whitespace that is part of
a difference which includes non-whitespace characters.)

To remove the highlighting, use \\[compare-windows-dehighlight]."
  (interactive "P")
  (require 'cl-lib)
  (require 'compare-w)
  (compare-windows-dehighlight)
  (let ((w1 (get-buffer-window))
        (w2 (funcall compare-windows-get-window-function)))
    (cl-letf ((w1p (window-point w1))
              (w2p (window-point w2))
              (compare-windows-highlight 'persistent)
              ((symbol-function 'compare-windows-dehighlight) #'ignore)
              ((symbol-function 'ding) (lambda () (error "done"))))
      (with-selected-window w1
        (goto-char (point-min)))
      (with-selected-window w2
        (goto-char (point-min)))
      (ignore-errors
        (while (compare-windows ignore-whitespace)))
      ;; Highlight any non-matching remainder in both buffers.
      (let ((b1 (window-buffer w1))
            (b2 (window-buffer w2))
            (p1 (window-point w1))
            (p2 (window-point w2))
            (max1 (with-selected-window w1 (point-max)))
            (max2 (with-selected-window w2 (point-max))))
        (compare-windows-highlight p1 max1 b1 w1 p2 max2 b2 w2))
      (set-window-point w1 w1p)
      (set-window-point w2 w2p))))

;; (defadvice kill-buffer (around my-kill-buffer-check activate)
;;   "Prompt when a buffer is about to be killed."
;;   (let* ((buffer-file-name (buffer-file-name))
;;          backup-file)
;;     ;; see 'backup-buffer
;;     (if (and (buffer-modified-p)
;;              buffer-file-name
;;              (file-exists-p buffer-file-name)
;;              (setq backup-file (car (find-backup-file-name buffer-file-name))))
;;         (let ((answer (completing-read (format "Buffer modified %s, (d)iff, (s)ave, (k)ill? " (buffer-name))
;;                                        '("d" "s" "k") nil t)))
;;           (cond ((equal answer "d")
;;                  (set-buffer-modified-p nil)
;;                  (let ((orig-buffer (current-buffer))
;;                        (file-to-diff (if (file-newer-than-file-p buffer-file-name backup-file)
;;                                          buffer-file-name
;;                                        backup-file)))
;;                    (set-buffer (get-buffer-create (format "%s last-revision" (file-name-nondirectory file-to-diff))))
;;                    (buffer-disable-undo)
;;                    (insert-file-contents file-to-diff nil nil nil t)
;;                    (set-buffer-modified-p nil)
;;                    (setq buffer-read-only t)
;;                    (ediff-buffers (current-buffer) orig-buffer)))
;;                 ((equal answer "k")
;;                  (set-buffer-modified-p nil)
;;                  ad-do-it)
;;                 (t
;;                  (save-buffer)
;;                  ad-do-it)))
;;       ad-do-it)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Improved alternative to backward-up-list
(defun backward-up-sexp (arg)
  (interactive "p")
  (let ((ppss (syntax-ppss)))
    (cond ((elt ppss 3)
           (goto-char (elt ppss 8))
           (backward-up-sexp (1- arg)))
          ((backward-up-list arg)))))

(global-set-key [remap backward-up-list] 'backward-up-sexp)


(defun my-semnav-up (arg)
  "Helper for `my-extend-selection'
By Nikolaj Schumacher, 2008-10-20. Licensed under GPL."
  (interactive "p")
  (when (nth 3 (syntax-ppss))
    (if (> arg 0)
        (progn
          (skip-syntax-forward "^\"")
          (goto-char (1+ (point)))
          (decf arg))
      (skip-syntax-backward "^\"")
      (goto-char (1- (point)))
      (incf arg)))
  (up-list arg))

;; Include any header comment when using narrow-to-defun
(defun my-narrow-to-defun ()
  (interactive)
  ;; Allow point to be within a leading comment.
  (save-excursion
    (let ((cstart (comment-beginning)))
      (when cstart
        (goto-char cstart)))
    (while (comment-forward))
    (narrow-to-defun)) ;; Default behaviour.
  (when (buffer-narrowed-p)
    (save-excursion
      (let ((min (point-min))
            (max (point-max)))
        (goto-char min)
        (widen)
        ;; If there's a preceding comment.
        (when (forward-comment -1)
          ;; Skip back over ALL preceding comments & whitespace.
          (while (forward-comment -1))
          ;; Skip forwards over any page delimiters within those comments.
          (when (and page-delimiter (not (string= page-delimiter "")))
            (while (re-search-forward page-delimiter min t)))
          ;; Skip past any blank lines.
          (skip-chars-forward "[:space:]\n")
          (beginning-of-line)
          ;; This is the new point to narrow from.
          (setq min (point)))
        (narrow-to-region min max)))))

(defun my-narrow-to-region-indirect (start end)
  "`narrow-to-region' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive "r")
  (deactivate-mark)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-region start end))
    (pop-to-buffer buf)))

(defun my-narrow-to-page-indirect (&optional arg)
  "`narrow-to-page' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive "P")
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-page arg))
    (pop-to-buffer buf)))

(defun my-narrow-to-defun-indirect (&optional _arg)
  "`narrow-to-defun' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (my-narrow-to-defun)) ; _arg
    (pop-to-buffer buf)))

(defun my-extend-selection (arg &optional incremental)
  "Mark the symbol surrounding point.
Subsequent calls mark higher levels of sexps.
By Nikolaj Schumacher, 2008-10-20. Licensed under GPL."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     (or (and transient-mark-mode mark-active)
                         (eq last-command this-command))))
  (if incremental
      (progn
        (my-semnav-up (- arg))
        (forward-sexp)
        (mark-sexp -1))
    (if (> arg 1)
        (my-extend-selection (1- arg) t)
      (if (looking-at "\\=\\(\\s_\\|\\sw\\)*\\_>")
          (goto-char (match-end 0))
        (unless (memq (char-before) '(?\) ?\"))
          (forward-sexp)))
      (mark-sexp -1))))

(defun my-copy-region-unindented (pad beginning end)
  "Copy the region, un-indented by the length of its minimum indent.

If numeric prefix argument PAD is supplied, indent the resulting
text by that amount."
  (interactive "P\nr")
  (let ((buf (current-buffer))
        (itm indent-tabs-mode)
        (tw tab-width)
        (st (syntax-table))
        (indent nil))
    (with-temp-buffer
      (setq indent-tabs-mode itm
            tab-width tw)
      (set-syntax-table st)
      (insert-buffer-substring buf beginning end)
      ;; Establish the minimum level of indentation.
      (goto-char (point-min))
      (while (and (re-search-forward "^[[:space:]\n]*" nil :noerror)
                  (not (eobp)))
        (let ((length (current-column)))
          (when (or (not indent) (< length indent))
            (setq indent length)))
        (forward-line 1))
      (if (not indent)
          (error "Region is entirely whitespace")
        ;; Un-indent the buffer contents by the length of the minimum
        ;; indent level, and copy to the kill ring.
        (when pad
          (setq indent (- indent (prefix-numeric-value pad))))
        (indent-rigidly (point-min) (point-max) (- indent))
        (copy-region-as-kill (point-min) (point-max))))))

(defun my-copy-region-as-kill (pad beginning end)
  "Like `copy-region-as-kill' or, with prefix arg, `my-copy-region-unindented'.

\\[universal-argument] causes minimal indentation for the copied region.

A numeric prefix argument pads the minimal indent by PAD columns.

See also `my-kill-region'."
  (interactive "P\nr")
  (if pad
      (my-copy-region-unindented (if (consp pad) nil pad)
                                 beginning end)
    (copy-region-as-kill beginning end)))

(defun my-kill-region (pad beginning end)
  "Like `kill-region'.  With prefix arg, also `my-copy-region-unindented'.

\\[universal-argument] causes minimal indentation for the copied region.

A numeric prefix argument pads the minimal indent by PAD columns.

See also `my-copy-region-as-kill'."
  (interactive "P\nr")
  (if pad
      (progn
        (my-copy-region-unindented (if (consp pad) nil pad)
                                   beginning end)
        (delete-region beginning end))
    (kill-region beginning end)))

(defun my-region-or-word (prompt)
  "Read a string from the minibuffer, prompting with PROMPT.
If `transient-mark-mode' is non-nil and the mark is active,
it defaults to the current region, else to the word at or before
point. This function returns a list (string) for use in `interactive'."
  (list (read-string prompt (or (and transient-mark-mode mark-active
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end)))
                                (current-word)))))

(defun my-hyphenate (beginning end)
  "Place hyphens between words in region."
  (interactive "*r")
  (save-excursion
    (goto-char beginning)
    (while (re-search-forward "[[:space:]\n]+" end :noerror)
      (replace-match "-"))))

(defcustom my-www-search-url
  "http://google.com/search?num=100&q=%s"
  "URL for WWW search, with %s placeholder for search string"
  :type 'string
  :group 'www)

(defalias 'my-render-url 'my-eww)
(eval-when-compile
  (defvar url-http-end-of-headers))
(defun my-eww (url)
  "Render URL as HTML."
  (declare (obsolete eww "24.4"))
  (interactive "sURL: ")
  (require 'shr)
  (url-retrieve
   url
   (lambda (&optional status cbargs)
     (let ((markup (current-buffer)))
       (delete-region (point-min) (1+ url-http-end-of-headers))
       (shr-render-buffer markup)
       (kill-buffer markup)))))

(defun my-www-search (string)
  "Ask a WWW browser to perform a web search for a given string.
Prompts for a string, defaulting to the active region or the current word at
or before point."
  (interactive (my-region-or-word "WWW search: "))
  (browse-url (format my-www-search-url (url-hexify-string string))))

(defcustom browse-url-palemoon-program "palemoon"
  "The name by which to invoke Palemoon."
  :type 'string
  :group 'browse-url)

(defcustom browse-url-palemoon-arguments nil
  "A list of strings to pass to Palemoon (or variant) as arguments."
  :type '(repeat (string :tag "Argument"))
  :group 'browse-url)

(defcustom browse-url-palemoon-new-window-is-tab nil
  "Whether to open up new windows in a tab or a new window.
If non-nil, then open the URL in a new tab rather than a new window if
`browse-url-palemoon' is asked to open it in a new window."
  :type 'boolean
  :group 'browse-url)

(defun browse-url-palemoon (url &optional new-window)
  "Ask the Palemoon WWW browser to load URL.
Defaults to the URL around or before point.  Passes the strings
in the variable `browse-url-palemoon-arguments' to Palemoon.

Interactively, if the variable `browse-url-new-window-flag' is non-nil,
loads the document in a new Palemoon window.  A non-nil prefix argument
reverses the effect of `browse-url-new-window-flag'.

If `browse-url-palemoon-new-window-is-tab' is non-nil, then
whenever a document would otherwise be loaded in a new window, it
is loaded in a new tab in an existing window instead.

Non-interactively, this uses the optional second argument NEW-WINDOW
instead of `browse-url-new-window-flag'."
  (interactive (browse-url-interactive-arg "URL: "))
  ;; `browse-url-maybe-new-window' is a macro.
  (eval-when-compile (require 'browse-url))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply 'start-process
           (concat "palemoon " url) nil
           browse-url-palemoon-program
           (append
            browse-url-palemoon-arguments
            (if (browse-url-maybe-new-window new-window)
                (if browse-url-palemoon-new-window-is-tab
                    '("-new-tab")
                  '("-new-window")))
            (list url)))))

(defvar my-ssh-history nil)
(defvar-local my-ssh-switches nil)
(put 'my-ssh-switches 'permanent-local t)
(defun my-ssh (args)
  "Connect to a remote host by SSH."
  ;; The following makes typing SPC a problem :/
  ;; (interactive
  ;;  (list (completing-read
  ;;         "ssh " my-ssh-history nil nil nil 'my-ssh-history)))
  (interactive
   (list (read-from-minibuffer "ssh " nil nil nil 'my-ssh-history)))
  (let* ((switches (split-string-and-unquote args))
         (name (concat "ssh " args))
         (termbuf (apply 'make-term name "ssh" nil switches)))
    (set-buffer termbuf)
    (setq-local my-ssh-switches switches)
    (term-mode)
    (term-char-mode)
    (switch-to-buffer termbuf)))

(defun my-terminal (delete-other-windows)
  "Switch to a `term' buffer (creating it if necessary)."
  (interactive "P")
  (require 'term)
  (unless (and term-ansi-buffer-name
               (buffer-name (get-buffer term-ansi-buffer-name))
               (get-buffer-process (get-buffer term-ansi-buffer-name)))
    (call-interactively 'ansi-term))
  (pop-to-buffer term-ansi-buffer-name '((display-buffer-reuse-window
                                          display-buffer-same-window)
                                         . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows))
  (setq-local term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

(defalias 'my-shell 'my-terminal)

(defun my-sql-console (delete-other-windows)
  "Switch to an interactive SQLi buffer (creating it if necessary)."
  (interactive "P")
  (require 'sql)
  (let ((sqlibuf
         (catch 'found
           (mapc (lambda (buf)
                   (with-current-buffer buf
                     (and (eq major-mode 'sql-interactive-mode)
                          (get-buffer-process buf)
                          (throw 'found buf))))
                 (buffer-list))
           nil)))
    (if sqlibuf
        (pop-to-buffer sqlibuf '((display-buffer-reuse-window
                                  display-buffer-same-window)
                                 . ((reusable-frames . visible))))
      (let ((current-prefix-arg '(4)))
        (let* ((sql-user
                (or (and (bound-and-true-p my-sql-db-user-getter)
                         (funcall my-sql-db-user-getter))
                    sql-user))
               (sql-database
                (or (and (bound-and-true-p my-sql-db-name-getter)
                         (funcall my-sql-db-name-getter))
                    sql-database)))
          (call-interactively 'sql-postgres)))))
  (when delete-other-windows
    (delete-other-windows)))

(defvar my-sql-query-buffer)

(defun my-sql-query-buffer (arg)
  "Open a `sql-mode' buffer which interacts with the current SQLi buffer.

Switches to an existing buffer if possible, otherwise creates a new buffer.

With C-u prefix arg, always creates a new buffer."
  (interactive "P")
  (let ((sqlibuf (current-buffer)))
    (if (null (sql-buffer-live-p sqlibuf))
        (error "Buffer %s is not a working SQLi buffer" sqlibuf)
      (let ((product sql-product)
            (querybuf
             (or (and (not (consp arg)) ;; prefix arg
                      (boundp 'my-sql-query-buffer)
                      (buffer-live-p (get-buffer my-sql-query-buffer))
                      (get-buffer my-sql-query-buffer))
                 (generate-new-buffer
                  (format "*SQL(CTL): %s*" (replace-regexp-in-string
                                           "\\*SQL: \\(.+\\)\\*" "\\1"
                                           (buffer-name sqlibuf)))))))
        (setq-local my-sql-query-buffer querybuf)
        (my-pop-to-buffer querybuf)
        (unless (eq major-mode 'sql-mode)
          (sql-mode)
          (setq sql-product product)
          (sql-highlight-product)
          (setq sql-buffer sqlibuf)
          (run-hooks 'sql-set-sqli-hook))))))

(defun my-drush-console (delete-other-windows)
  (interactive "P")
  (require 'drush-php)
  (unless (get-buffer-process (get-buffer "*Drush-PHP*"))
    (call-interactively 'run-drush-php))
  (pop-to-buffer "*Drush-PHP*" '((display-buffer-reuse-window
                                  display-buffer-same-window)
                                 . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows)))

(defvar my-terminal-run-history nil)
(defun my-terminal-run (command &optional name)
  "Runs COMMAND in a `term' buffer."
  (interactive
   (list (read-from-minibuffer "$ " nil nil nil 'my-terminal-run-history)))
  (let* ((name (or name command))
         (switches (split-string-and-unquote command))
         (command (pop switches))
         (termbuf (apply 'make-term name command nil switches)))
    (set-buffer termbuf)
    (term-mode)
    (term-char-mode)
    (switch-to-buffer termbuf)))

(defvar watch-history nil)
(defun watch (command &optional name)
  "Runs \"watch COMMAND\" in a `term' buffer.  \"q\" to exit."
  (interactive
   (list (read-from-minibuffer "watch " nil nil nil 'watch-history)))
  (let* ((name (or name (concat "watch " command)))
         (switches (split-string-and-unquote command))
         (termbuf (apply 'make-term name "watch" nil switches))
         (proc (get-buffer-process termbuf)))
    (set-buffer termbuf)
    (term-mode)
    (term-char-mode)
    (setq show-trailing-whitespace nil)
    ;; Kill the process interactively with "q".
    (set-process-query-on-exit-flag proc nil)
    (let ((map (make-sparse-keymap))
          (cmdquit (make-symbol "watch-quit")))
      (put cmdquit 'function-documentation "Kill the `watch' buffer.")
      (put cmdquit 'interactive-form '(interactive))
      (fset cmdquit (apply-partially 'kill-process proc))
      (set-keymap-parent map (current-local-map))
      (define-key map (kbd "q") cmdquit)
      (use-local-map map))
    ;; Kill the buffer automatically when the process is killed.
    (set-process-sentinel
     proc (lambda (process signal)
            (and (memq (process-status process) '(exit signal))
                 (buffer-live-p (process-buffer process))
                 (kill-buffer (process-buffer process)))))
    ;; Display the buffer.
    (switch-to-buffer termbuf)))

(defun my-pop-to-buffer (buf &optional delete-other-windows)
  "Switch to buffer BUF, and optionally maximise the window in its frame.
Re-use an existing window containing BUF (in a visible frame) by preference,
otherwise use the current selected window."
  (pop-to-buffer buf '(display-buffer-reuse-window
                       . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows)))

(defun my-ibuffer (arg)
  "Switch to ibuffer. Exit ibuffer, if current.

If ibuffer is already visible in another window, switch to that
window. If a prefix argument is supplied, we open ibuffer in the
current window even if another window is also displaying it."
  (interactive "P")
  (if (eq major-mode 'ibuffer-mode)
      (if (fboundp 'ibuffer-quit)
          (ibuffer-quit)
        (quit-window))
    (if arg
        (ibuffer)
      (let ((win (get-buffer-window "*Ibuffer*" (selected-frame))))
        (if (window-live-p win)
            (select-window win)
          (ibuffer))))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value.

https://github.com/magnars/.emacs.d/blob/master/defuns/lisp-defuns.el"
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun my-eval-remote-library (url)
  "Retrieve and evaluate the code in the specified URL."
  (interactive "sURL: ")
  (save-window-excursion
    (eval-buffer
     (browse-url-emacs url))))

(defun my-toggle-fill-paragraph ()
  "Fill or unfill the current paragraph, depending upon the current line length.
When there is a text selection, act on the region.
See `fill-paragraph' and `fill-region'."
  (interactive)
  ;; We set a property 'currently-filled-p on this command's symbol
  ;; (i.e. on 'my-toggle-fill-paragraph), thus avoiding the need to
  ;; create a variable for remembering the current fill state.
  (save-excursion
    (let* ((deactivate-mark nil)
           (line-length (- (line-end-position) (line-beginning-position)))
           (currently-filled (if (eq last-command this-command)
                                 (get this-command 'currently-filled-p)
                               (< line-length fill-column)))
           (fill-column (if currently-filled
                            most-positive-fixnum
                          fill-column)))

      (if (region-active-p)
          (fill-region (region-beginning) (region-end))
        (fill-paragraph))

      (put this-command 'currently-filled-p (not currently-filled)))))

(defmacro with-temporary-advice (function class name &rest body)
  "Enable the specified advice, evaluate BODY, then disable the advice."
  `(unwind-protect
       (progn
         (ad-enable-advice ,function ,class ,name)
         (ad-activate ,function)
         ,@body)
     (ad-disable-advice ,function ,class ,name)
     (ad-activate ,function)))

(defun my-load-all-in-directory (dir &optional file-pattern)
  "`load' all elisp libraries in directory DIR which are not already loaded.

Optionally consider only filenames matching regexp FILE-PATTERN, which is
matched against each base filename (i.e. `file-name-nondirectory'). By default
all .el and .elc files are considered.

Note that the matching files are processed sans-extension, thus prioritising
and loading .elc files over .el files. So even if FILE-PATTERN matched only
the .el files, the .elc variants would be loaded instead, where present."
  (interactive "D")
  (let ((file-pattern (or file-pattern ".+\\.elc?$"))
        (libraries-loaded (mapcar #'file-name-sans-extension
                                  (delq nil (mapcar #'car load-history)))))
    (dolist (file (directory-files dir t file-pattern t))
      (let ((library (file-name-sans-extension file)))
        (unless (member library libraries-loaded)
          (load library)
          (push library libraries-loaded))))))

;; It's simpler without FILE-PATTERN:
;;
;; (defun my-load-all-in-directory (dir)
;;   "`load' all elisp libraries in directory DIR which are not already loaded."
;;   (interactive "D")
;;   (let ((libraries-loaded (mapcar #'file-name-sans-extension
;;                                   (delq nil (mapcar #'car load-history)))))
;;     (dolist (file (directory-files dir t ".+\\.elc?$" t))
;;       (let ((library (file-name-sans-extension file)))
;;         (unless (member library libraries-loaded)
;;           (load library)
;;           (push library libraries-loaded))))))

(defun my-copy-eterm-color-terminfo (hostspec)
  "Copy the eterm-color terminfo files to a remote host.
HOSTSPEC is a tramp host specification such as \"localhost\"
or \"user@example.com\""
  ;; http://stackoverflow.com/a/21006365/324105
  (interactive
   (let ((hosts (mapcar (lambda (x)
                          (cond ((stringp x) x)
                                ((null (car x)) (cadr x))
                                (t (concat (car x) "@" (cadr x)))))
                        (apply 'append
                               (mapcar
                                (lambda (x)
                                  (cl-remove-if-not 'identity
                                                    (apply (car x) (cdr x))))
                                (tramp-get-completion-function "ssh"))))))
     (list (completing-read "Hostname: " hosts nil 'confirm nil nil hosts nil))))
  (let ((destdir (format "/ssh:%s:~/.terminfo/e/" hostspec)))
    (unless (file-directory-p destdir)
      (dired-create-directory destdir))
    (copy-file (concat data-directory "e/eterm-color") destdir)
    (copy-file (concat data-directory "e/eterm-color.ti") destdir)))

(defun my-terminal-cursor-color (color)
  "Sets the terminal cursor colour by sending the appropriate escape sequence."
  (interactive
   (list (read-color "Color (white): " nil :allow-empty)))
  (when (string= color "")
    (setq color "white"))
  (send-string-to-terminal
   (concat "\033]12;" color "\007")))

(defvar my-emacs-uptime-log (locate-user-emacs-file "uptime.log")
  "Log file for `my-log-emacs-uptime'.")

(defun my-log-emacs-start-time ()
  "Write emacs start time to `my-emacs-uptime-log'.

If emacs doesn't get a chance to shut down cleanly, this may
still give me some idea of how long it was running for."
  (with-temp-buffer
    (insert (format "PID %d started at " (emacs-pid))
            (format-time-string "%Y-%m-%d %H:%M:%S" (current-time)) "\n")
    (append-to-file nil nil my-emacs-uptime-log)))

(defun my-log-emacs-uptime ()
  "Write emacs uptime to `my-emacs-uptime-log'. Use with `kill-emacs-hook'."
  (with-temp-buffer
    (insert (format-time-string "%Y-%m-%d %H:%M:%S" before-init-time) " to "
            (format-time-string "%Y-%m-%d %H:%M:%S" (current-time)) " = "
            (emacs-uptime) (format " (PID %d)\n" (emacs-pid)))
    (append-to-file nil nil my-emacs-uptime-log)))

(defun my-insert-kbd (key)
  ;; Based on http://emacs.stackexchange.com/a/2208/454
  "Ask for a key, then insert its description using <kbd> markup.
Will work in org-mode or in any mode that accepts plain html."
  (interactive "kType key sequence: ")
  (let* ((is-org-mode (derived-mode-p 'org-mode))
         (output (if is-org-mode
                     "@@html:<kbd>%s</kbd>@@"
                   "<kbd>%s</kbd>")))
    (if (not (equal key "\r")) ;; empty key
        (insert
         (format output
                 (mapconcat (lambda (s)
                              (replace-regexp-in-string "<" "&lt;" s))
                            (split-string (help-key-description key nil))
                            "</kbd><kbd>")))
      (insert (format output ""))
      (forward-char (if is-org-mode -8 -6)))))

(defun display-buffer-reuse-major-mode-window (buffer alist)
  "Return a window displaying a buffer in BUFFER's major mode.
Return nil if no usable window is found.

If ALIST has a non-nil `inhibit-same-window' entry, the selected
window is not eligible for reuse.

If ALIST contains a `reusable-frames' entry, its value determines
which frames to search for a reusable window:
  nil -- the selected frame (actually the last non-minibuffer frame)
  A frame   -- just that frame
  `visible' -- all visible frames
  0   -- all frames on the current terminal
  t   -- all frames.

If ALIST contains no `reusable-frames' entry, search just the
selected frame if `display-buffer-reuse-frames' and
`pop-up-frames' are both nil; search all frames on the current
terminal if either of those variables is non-nil.

If ALIST has a non-nil `inhibit-switch-frame' entry, then in the
event that a window on another frame is chosen, avoid raising
that frame."
  (let* ((alist-entry (assq 'reusable-frames alist))
         (frames (cond (alist-entry (cdr alist-entry))
                       ((if (eq pop-up-frames 'graphic-only)
                            (display-graphic-p)
                          pop-up-frames)
                        0)
                       (display-buffer-reuse-frames 0)
                       (t (last-nonminibuffer-frame))))
         (window (let ((mode (buffer-local-value 'major-mode buffer)))
                   (if (and (eq mode (buffer-local-value 'major-mode
                                                         (window-buffer)))
                            (not (cdr (assq 'inhibit-same-window alist))))
                       (selected-window)
                     (catch 'window
                       (walk-windows
                        (lambda (w)
                          (and (window-live-p w)
                               (eq mode (buffer-local-value 'major-mode
                                                            (window-buffer w)))
                               (not (eq w (selected-window)))
                               (throw 'window w)))
                        'nomini frames))))))
    (when (window-live-p window)
      (prog1 (window--display-buffer buffer window 'reuse alist)
        (unless (cdr (assq 'inhibit-switch-frame alist))
          (window--maybe-raise-frame (window-frame window)))))))

;; I bind `apropos-do-all' non-nil by default, so these commands act
;; as replacements for `apropos-command' and `apropos-user-option' and
;; ensure that only commands and user options are displayed.

(defun my-apropos-command (pattern)
  "Show commands (interactively callable functions) that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words."
  (interactive (list (apropos-read-pattern "command")))
  (let ((apropos-do-all nil))
    (apropos-command pattern)))

(defun my-apropos-user-option (pattern)
  "Show user options that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words."
  (interactive (list (apropos-read-pattern "user option")))
  (let ((apropos-do-all nil))
    (apropos-user-option pattern)))

;; Testing the modification timestamp for a file or directory
;; (directory tree version finds the latest mtime for any child)

(defun my-buffer-file-last-modified (file-name)
  "Return a timestamp for the most recent modification to the specified file.
We assume that a buffer is visiting the most recent version of this time."
  (let ((buffer (get-file-buffer file-name)))
    (when buffer
      (string-to-number
       (format-time-string
        "%s" (with-current-buffer (get-file-buffer file-name)
               (visited-file-modtime)))))))

(defun my-directory-tree-last-modified (dir)
  "Return a timestamp for the most recent modification under the specified dir."
  (string-to-number
   (shell-command-to-string
    (format
     (concat
      " max=0; find %s -print0"; dir
      " | xargs -0 stat --format=%%Y"
      " | while read -r ts; do test $ts -gt $max && max=$ts && echo $max; done"
      " | tail -1")
     (shell-quote-argument dir)))))

(defun my-trace-package (prefix)
  "Trace all functions which start with PREFIX.
For example, to trace all ELP functions, do the following:

    \\[my-trace-package] RET elp- RET"
  (interactive ;; derived from `elp-instrument-package'.
   (list (completing-read "Prefix of package to trace: "
                          obarray 'my-traceable-p)))
  (if (zerop (length prefix))
      (error "Tracing all Emacs functions would render Emacs unusable"))
  (mapc (lambda (name)
          (trace-function-foreground (intern name)))
        (all-completions prefix obarray 'my-traceable-p))
  (message "Use %s to cease tracing."
           (substitute-command-keys "\\[untrace-all]")))

(defun my-traceable-p (fun)
  "Predicate for `my-trace-package'."
  ;; Derived from `elp-profilable-p'. Fewer restrictions are needed here.
  (and (symbolp fun)
       (fboundp fun)
       (not (keymapp fun))))

(defun password-composer (domain)
  "Run password-composer."
  (interactive "sDomain: ")
  (let ((buf (make-comint-in-buffer
              "password-composer" nil "password-composer" nil domain)))
    (set-buffer buf)
    (setq comint-process-echoes nil)
    (pop-to-buffer buf)
    (send-invisible "Password: ")
    (use-local-map
     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map (current-local-map))
       (define-key map "q" `(lambda () (interactive) (kill-buffer ,buf)))
       map))))

(defvar domain-hash-history nil
  "Domain history for `domain-hash-arguments'.")
(defvar domain-hash-algorithm 'sha256
  "Any valid `secure-hash' algorithm.")
(defvar domain-hash-length nil
  "The length of substring returned by `domain-hash'.
nil to return the complete hash.")

(defun domain-hash-arguments (&optional algorithm)
  "Obtain interactive arguments for `domain-hash' and friends."
  (let ((args
         (list (let ((default (car domain-hash-history)))
                 (read-string (if default
                                  (format "Domain (%s): " default)
                                "Domain: ")
                              nil 'domain-hash-history default))
               (read-passwd "Passphrase: ")
               current-prefix-arg)))
    (if algorithm
        (append args (list (intern (completing-read
                                    (if domain-hash-algorithm
                                        (format "Algorithm (%s): "
                                                domain-hash-algorithm)
                                      "Algorithm: ")
                                    (secure-hash-algorithms)
                                    nil t nil nil (symbol-name
                                                   domain-hash-algorithm)))))
      args)))

(defun domain-hash (domain passphrase &optional kill algorithm)
  "Hash a PASSPHRASE:DOMAIN combination.

With prefix-arg copies hash to kill-ring, otherwise inserts it."
  (interactive (domain-hash-arguments t))
  (let* ((hash (substring-no-properties
                (secure-hash (or algorithm domain-hash-algorithm)
                             (concat passphrase ":" domain))
                0 domain-hash-length))
         (dots (propertize
                hash 'display (make-string (length hash) ?.))))
    (if kill
        (kill-new dots)
      (insert dots))))

(defun domain-hash-md5 (domain passphrase &optional kill)
  "`domain-hash' using the md5 algorithm."
  (interactive (domain-hash-arguments))
  (let ((domain-hash-algorithm 'md5)
        (domain-hash-length 8))
    (domain-hash domain passphrase kill)))

(defun my-crontab-edit ()
  "Edit crontab."
  (interactive)
  (require 'with-editor)
  (with-editor-async-shell-command "crontab -e"))

;; https://fuco1.github.io/2017-05-06-Enhanced-beginning--and-end-of-buffer-in-special-mode-buffers-%28dired-etc.%29.html

(defmacro my-special-buffer-pos (library fname doc pos remap mode &rest forms)
  "Helper for `my-define-bob' and `my-define-eob'."
  (let ((modename (symbol-name mode)))
    (let (;;(fname (intern (concat "my-" modename "-" (symbol-name remap))))
          (mode-map (intern (concat modename "-map")))
          (mode-hook (intern (concat modename "-hook"))))
      `(progn
         (defalias ',fname
           (lambda ()
             (interactive)
             (let ((p (point)))
               (goto-char (,pos))
               ,@forms
               (when (= p (point))
                 (goto-char (,pos)))))
           ,doc)
         (eval-after-load ,library
           '(progn
              (defvar ,mode-map) ;; Silence compiler warnings.
              (define-key ,mode-map [remap ,remap] #',fname)))))))

(defmacro my-define-bob (fname mode library &rest forms)
  "Define a special version of `beginning-of-buffer' in MODE.

The special function is defined such that the point first moves
to `point-min' and then FORMS are evaluated.  If the point did
not change because of the evaluation of FORMS, jump
unconditionally to `point-min'.  This way repeated invocations
toggle between real beginning and logical beginning of the
buffer."
  (declare (indent 3))
  (let ((doc "Toggle between the logical and real beginning of the buffer."))
    `(my-special-buffer-pos
      ,library ,fname ,doc point-min beginning-of-buffer ,mode ,@forms)))

(defmacro my-define-eob (fname mode library &rest forms)
  "Define a special version of `end-of-buffer' in MODE.

The special function is defined such that the point first moves
to `point-max' and then FORMS are evaluated.  If the point did
not change because of the evaluation of FORMS, jump
unconditionally to `point-max'.  This way repeated invocations
toggle between real end and logical end of the buffer."
  (declare (indent 3))
  (let ((doc "Toggle between the logical and real end of the buffer."))
    `(my-special-buffer-pos
      ,library ,fname ,doc point-max end-of-buffer ,mode ,@forms)))

;; Awkwardly, `find-function' will find these definitions only when
;; the regexp "^([^ ]+ FUNCTION-NAME" can be found, which places
;; several constraints upon how we define these functions (including
;; being needing to pass the library name, as we are not able to wrap
;; the definitions themselves in eval-after-load due to indentation).
;; See `find-function-search-for-symbol'.
;;
;; `find-function-regexp-alist' can solve this, I suspect? Argh,
;; except `find-function-noselect' passes `nil' for TYPE which means
;; that `find-function-regexp' is always used, so I would need to
;; modify that. (Can't we have a symbol property to specify the type?)
;;
;; diff -u lisp/emacs-lisp/find-func.el.gz
;; --- /usr/local/share/emacs/25.2/lisp/emacs-lisp/find-func.el.gz
;; +++ #<buffer find-func.el.gz>
;; @@ -301,6 +301,8 @@
;;  The search is done in the source for library LIBRARY."
;;    (if (null library)
;;        (error "Don't know where `%s' is defined" symbol))
;; +  (unless type
;; +    (setq type (get symbol 'find-function-type)))
;;    ;; Some functions are defined as part of the construct
;;    ;; that defines something else.
;;    (while (and (symbolp symbol) (get symbol 'definition-name))
;;
;; Diff finished.  Tue May  9 18:09:11 2017

;; Alternatively (additionally?) `elisp-xref-find-def-functions' can
;; presumably make these findable without such constraints.  I would
;; need to ensure that I actually use xref, though.

(defvar my-find-special-buffer-pos-regexp
  "^\\s-*(my-define-[be]ob %s\\_>"
  "Used in `find-function-regexp-alist' for finding definitions.")

(eval-after-load "find-func"
  '(add-to-list 'find-function-regexp-alist
                '(my-special-buffer-pos . my-find-special-buffer-pos-regexp)
                :append))

;; Silence compiler warnings
(eval-when-compile
  (declare-function bs-down "bs")
  (declare-function bs-up "bs")
  (declare-function compilation-next-error "compile")
  (declare-function compilation-previous-error "compile")
  (declare-function dired-next-line "dired")
  (declare-function dired-previous-line "dired")
  (declare-function ibuffer-backward-line "ibuffer")
  (declare-function ibuffer-forward-line "ibuffer")
  (declare-function occur-next "replace")
  (declare-function occur-prev "replace")
  (declare-function org-agenda-next-item "org-agenda")
  (declare-function org-agenda-previous-item "org-agenda")
  (declare-function vc-dir-next-line "vc-dir")
  (declare-function vc-dir-previous-line "vc-dir")
  )

;; Dired (M-x dired)
(with-eval-after-load "dired"
  (my-define-bob my-dired-beginning-of-buffer
      dired-mode "dired"
    (while (not (ignore-errors (dired-get-filename)))
      (dired-next-line 1)))
  (my-define-eob my-dired-end-of-buffer
      dired-mode "dired"
    (dired-previous-line 1)))

;; Occur (M-x occur)
(my-define-bob my-occur-beginning-of-buffer
    occur-mode "replace"
  (occur-next 1))
(my-define-eob my-occur-end-of-buffer
    occur-mode "replace"
  (occur-prev 1))

;; Ibuffer (M-x ibuffer)
(my-define-bob my-ibuffer-beginning-of-buffer
    ibuffer-mode "ibuffer"
  (ibuffer-forward-line 1))
(my-define-eob my-ibuffer-end-of-buffer
    ibuffer-mode "ibuffer"
  (ibuffer-backward-line 1))

;; Org Agenda (M-x org-agenda)
(my-define-bob my-org-agenda-beginning-of-buffer
    org-agenda-mode "org-agenda"
  (org-agenda-next-item 1))
(my-define-eob my-org-agenda-end-of-buffer
    org-agenda-mode "org-agenda"
  (org-agenda-previous-item 1))

;; grep, rgrep, etc...
(my-define-bob my-grep-beginning-of-buffer
    grep-mode "grep"
  (compilation-next-error 1))
(my-define-eob my-grep-end-of-buffer
    grep-mode "grep"
  (compilation-previous-error 1))

;; vc directory view (M-x vc-dir or C-x v d)
(my-define-bob my-vc-dir-beginning-of-buffer
    vc-dir-mode "vc-dir"
  (vc-dir-next-line 1))
(my-define-eob my-vc-dir-end-of-buffer
    vc-dir-mode "vc-dir"
  (vc-dir-previous-line 1))

;; bs (M-x bs-show)
(my-define-bob my-bs-beginning-of-buffer
    bs-mode "bs"
  (bs-down 2))
(my-define-eob my-bs-end-of-buffer
    bs-mode "bs"
  (bs-up 1)
  (bs-down 1))

;; Recentf (M-x recentf-open-files)
(my-define-bob my-recentf-dialog-beginning-of-buffer
    recentf-dialog-mode "recentf"
  (when (re-search-forward "^  \\[" nil t)
    (goto-char (match-beginning 0))))
(my-define-eob my-recentf-dialog-end-of-buffer
    recentf-dialog-mode "recentf"
  (re-search-backward "^  \\[" nil t))

(defmacro loop-collect (item &rest loop)
  "Emulate list comprehension syntax/order for `cl-loop'.

\(loop-collect x for x in ...) => (cl-loop for x in ... collect x)"
  (require 'cl-macs)
  `(cl-loop ,@loop collect ,item))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'my-utilities)

;;; Local Variables:
;;; eval:(outline-minor-mode 1)
;;; eval:(hide-body)
;;; End:
