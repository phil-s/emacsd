;; -*- lexical-binding: t; -*-

(require 'cl-lib)

;; Silence compiler warnings
(eval-when-compile
  (defvar compare-windows-get-window-function)
  (defvar dired-mode-map)
  (defvar find-function-regexp-alist)
  (defvar find-grep-options)
  (defvar sort-fold-case)
  (defvar sql-buffer)
  (defvar sql-database)
  (defvar sql-product)
  (defvar sql-user)
  (defvar tags-loop-operate)
  (defvar tags-loop-scan)
  (defvar term-ansi-buffer-name)
  (defvar term-prompt-regexp)
  (defvar url-http-end-of-headers)
  (defvar url-http-target-url)
  (defvar view-exit-action)
  (declare-function aw-select "ace-window")
  (declare-function browse-url-encode-url "browse-url")
  (declare-function browse-url-interactive-arg "browse-url")
  (declare-function browse-url-process-environment "browse-url")
  (declare-function comint-send-invisible "comint")
  (declare-function compare-windows-dehighlight "compare-w")
  (declare-function compare-windows-highlight "compare-w")
  (declare-function dired-add-file "dired-aux")
  (declare-function dired-create-directory "dired-aux")
  (declare-function dired-current-directory "dired")
  (declare-function dired-get-marked-files "dired")
  (declare-function dired-move-to-filename "dired")
  (declare-function dired-nondirectory-p "dired-aux")
  (declare-function dired-virtual-mode "dired-x")
  (declare-function fileloop-continue "fileloop")
  (declare-function he-substitute-string "hippie-exp")
  (declare-function ibuffer-quit "ibuffer")
  (declare-function notifications-notify "notifications")
  (declare-function shr-render-buffer "shr")
  (declare-function sql-buffer-live-p "sql")
  (declare-function sql-highlight-product "sql")
  (declare-function tags--compat-files "etags")
  (declare-function term-char-mode "term")
  (declare-function term-mode "term")
  (declare-function term-send-raw-string "term")
  (declare-function totp-as-clipboard "totp")
  (declare-function tramp-dissect-file-name "tramp")
  (declare-function tramp-file-name-host "tramp")
  (declare-function tramp-file-name-localname "tramp")
  (declare-function tramp-file-name-method "tramp")
  (declare-function tramp-file-name-port "tramp")
  (declare-function tramp-file-name-user "tramp")
  (declare-function tramp-get-completion-function "tramp")
  (declare-function tramp-tramp-file-p "tramp")
  (declare-function url-filename "url-parse")
  (declare-function winner-redo "winner")
  (declare-function winner-undo "winner")
  (declare-function with-editor-async-shell-command "with-editor")
  )

;; (defun my-ido-filename ()
;;   "Return the filename selected with ido."
;;   (interactive)
;;   (flet ((ido-visit-buffer (filename &rest) filename)
;;          (find-file-noselect (filename &rest) filename))
;;     (let ((filename (ido-file-internal nil)))
;;       (message filename)
;;       filename)))

(defun set-region-read-only (begin end)
  "Sets the read-only text property on the marked region.

Use `set-region-writeable' to remove this property."
  ;; See https://stackoverflow.com/questions/7410125
  (interactive "r")
  (with-silent-modifications
    (put-text-property begin end 'read-only t)))

(defun set-region-writeable (begin end)
  "Removes the read-only text property from the marked region.

Use `set-region-read-only' to set this property."
  ;; See https://stackoverflow.com/questions/7410125
  (interactive "r")
  (with-silent-modifications
    (remove-text-properties begin end '(read-only t))))

(eval-when-compile
  (defvar he-num)
  (defvar he-search-string)
  (defvar he-tried-table)
  (declare-function he-substitute-string "hippie-exp"))

(defun my-hippie-expand-completions (&optional hippie-expand-function)
  "Return the full list of possible completions generated by `hippie-expand'.
The optional argument can be generated with `make-hippie-expand-function'."
  (let ((this-command 'my-hippie-expand-completions)
        (last-command last-command)
        (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
    ;; avoid the (ding) when hippie-expand exhausts its options.
    (cl-letf (((symbol-function 'ding) 'ignore))
      ;; Evaluating the completions modifies the buffer, however we
      ;; will finish up in the same state that we began.
      (with-silent-modifications
        (while (progn
                 (funcall hippie-expand-function nil)
                 (setq last-command 'my-hippie-expand-completions)
                 (not (equal he-num -1))))))
    ;; Provide the options in the order in which they are normally generated.
    (delete he-search-string (reverse he-tried-table))))

(declare-function he-substitute-string "hippie-exp" (STR &optional TRANS-CASE))
(defmacro my-ido-hippie-expand-with (hippie-expand-function)
  "Generate an interactively-callable function that offers ido-based completion
using the specified hippie-expand function."
  `(lambda (&optional selection)
     (interactive
      (let ((options (my-hippie-expand-completions ,hippie-expand-function)))
        (when options
          (list (ido-completing-read "Completions: " options)))))
     (if selection
         (progn
           (undo-boundary)
           (he-substitute-string selection t))
       (message "No expansion found"))))

(defun my-ido-hippie-expand ()
  "Offer ido-based completion for the word at point."
  (interactive)
  (call-interactively (my-ido-hippie-expand-with 'hippie-expand)))

(defun my-ido-hippie-expand-filename ()
  "Offer ido-based completion for the filename at point."
  (interactive)
  (call-interactively
   (my-ido-hippie-expand-with
    (make-hippie-expand-function '(try-complete-file-name)))))

;; Functions/keys for moving within and switching between
;; buffers and windows

(defun expand-other-window ()
  "Move to and expand the next window"
  (interactive)
  (other-window 1)
  (delete-other-windows))


;; @see https://gist.github.com/1415844
(defun my-rotate-left (l) (append (cdr l) (list (car l))))
(defun my-rotate-windows ()
  (let ((start-positions (my-rotate-left (mapcar 'window-start (window-list))))
        (buffers (my-rotate-left (mapcar 'window-buffer (window-list)))))
    (cl-mapcar (lambda (window buffer pos)
                 (set-window-buffer window buffer)
                 (set-window-start window pos))
               (window-list)
               buffers
               start-positions)))

(defun kill-other-buffer ()
  "Kill the next buffer, and expand the current one"
  (interactive)
  (other-window 1)
  (kill-buffer nil)
  (other-window -1)
  (delete-other-windows))

(defun split-window-vertically-change-buffer ()
  "Split the window vertically, and switch to the next buffer"
  (interactive)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer (other-buffer)))

(defun my-other-frame (arg)
  "If there is no other-frame, ring the bell."
  (interactive "p")
  (if (eq (next-frame (selected-frame)) (selected-frame))
      (ding)
    (other-frame arg)))

(defun my-align-next-window ()
  "Move point in `next-window' to the same line as the current window."
  (interactive)
  (recenter)
  (let ((line (line-number-at-pos)))
    (with-selected-window (next-window)
      (recenter)
      (goto-char (point-min))
      (forward-line (1- line)))))

(defun my-scroll-one-line-ahead ()
  "Scroll ahead one line"
  (interactive)
  (scroll-up 1)
  (forward-line 1))

(defun my-scroll-one-line-back ()
  "Scroll back one line"
  (interactive)
  (scroll-down 1)
  (forward-line -1))

(defun my-transient-repeat-map ()
  "Cause the last command key to repeat the current command."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map last-command-event this-command))))

(defun my-scroll-one-line-transient-repeat-map ()
  "Cause the last command key to repeat the current command."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "n") #'my-scroll-one-line-ahead-repeatable)
     (define-key map (kbd "p") #'my-scroll-one-line-back-repeatable)
     (define-key map (kbd "SPC") #'ignore)
     map)))

(defun my-scroll-one-line-ahead-repeatable ()
  "Scroll ahead one line; repeat with last command key."
  (interactive)
  (my-scroll-one-line-ahead)
  (my-scroll-one-line-transient-repeat-map))

(defun my-scroll-one-line-back-repeatable ()
  "Scroll back one line; repeat with last command key."
  (interactive)
  (my-scroll-one-line-back)
  (my-scroll-one-line-transient-repeat-map))

;; (defun my-multi-occur-in-matching-buffers (regexp &optional allbufs)
;;   "Show all lines matching REGEXP in all buffers.
;; Enhance this to ignore other known-bad files?
;; http://stackoverflow.com/questions/2641211/emacs-interactively-search-open-buffers/2642655#2642655

;; TODO: Re-write to *positively* match and delete bad buffer names from
;; the list of all buffers, and pass the resulting list into `multi-occur',
;; instead of using `multi-occur-in-matching-buffers'.
;; "
;;   (interactive (occur-read-primary-args))
;;   (let* ((not-tags "\\([^T]\\|T[^A]\\|TA[^G]\\|TAG[^S]\\|TAGS.\\)")
;;          (exclude-tags-pattern (if allbufs
;;                                    (concat "^" not-tags)
;;                                  (concat "/" not-tags "[^/]*$"))))
;;     (multi-occur-in-matching-buffers
;;      exclude-tags-pattern
;;      regexp)))

(defvar my-multi-occur-buffers-file-name-exclusions '("TAGS")
  "List of file names to exclude from my-multi-occur,
ignoring the directory path.")

(defvar my-multi-occur-buffers-file-path-exclusions nil
  "List of file paths to exclude from my-multi-occur.")

(defun my-multi-occur-buffers (&optional non-file-buffers)
  "List of file-visiting buffers, excluding any known unwanted buffers."
  (let* ((list (buffer-list))
         (buffers list))
    (while buffers
      (let* ((buffer (car buffers))
             (next (cdr buffers))
             (buffer-name (buffer-name buffer))
             (file-name (buffer-file-name buffer))
             (file-name-exclusions my-multi-occur-buffers-file-name-exclusions))
        ;; Exclude non-file and internal-use buffers.
        (when (or (string= (substring buffer-name 0 1) " ") ;; internal
                  (not (or file-name non-file-buffers))
                  (and file-name
                       (or (member file-name file-name-exclusions)
                           (member (file-name-nondirectory file-name)
                                   file-name-exclusions))))
          (setq list (delq buffer list)))
        (setq buffers next)))
    list))

(defun my-multi-occur (regexp &optional nlines)
  "Show lines matching REGEXP in all file-visiting buffers.
With raw prefix arg C-u also include non-file buffers, otherwise
any numeric prefix argument is passed to `occur' as nlines."
  (interactive
   (if (consp current-prefix-arg)
       (list (car (occur-read-primary-args)) 'non-file-buffers)
     (occur-read-primary-args)))
  (if (eq nlines 'non-file-buffers)
      (multi-occur (my-multi-occur-buffers t) regexp)
    (multi-occur (my-multi-occur-buffers) regexp nlines)))

(defun my-multi-occur-in-visible-buffers (regexp &optional _arg)
  "Show all lines matching REGEXP in the current frame's visible buffers."
  (interactive (occur-read-primary-args)) ;; optional arg required but ignored
  (let ((visible-buffers nil))
    (walk-windows (lambda (window)
                    (add-to-list 'visible-buffers (window-buffer window))))
    (multi-occur visible-buffers regexp)))

(eval-when-compile
  (declare-function term-send-raw-string "term" (chars))
  (declare-function term-mode "term" ())
  (declare-function term-char-mode "term" ())
  (require 'term) ;; `term-in-char-mode' is a macro.
  )
(defun my-forward-word-or-buffer-or-windows (&optional arg)
  "Enable <C-left> to call `next-buffer' if the last command was
`next-buffer' or `previous-buffer', and `winner-redo' if the last
command was `winner-undo' or `winner-redo'."
  (interactive "p")
  (cond ((memq last-command (list 'next-buffer 'previous-buffer))
         (progn (next-buffer)
                (setq this-command 'next-buffer)))
        ((memq last-command (list 'winner-redo 'winner-undo))
         (progn (winner-redo)
                (setq this-command 'winner-redo)))
        ((and (derived-mode-p 'term-mode)
              (require 'term)      ; for byte-compilation
              (term-in-char-mode)) ; <- macro expansion
         (term-send-raw-string "f"))
        (t ;else
         (progn (forward-word arg)
                (setq this-command 'forward-word)))))

(defun my-backward-word-or-buffer-or-windows (&optional arg)
  "Enable <C-left> to call `previous-buffer' if the last command was
`next-buffer' or `previous-buffer', and `winner-undo' if the last
command was `winner-undo' or `winner-redo'."
  (interactive "p")
  (cond ((memq last-command (list 'next-buffer 'previous-buffer))
         (progn (previous-buffer)
                (setq this-command 'previous-buffer)))
        ((memq last-command (list 'winner-redo 'winner-undo))
         (progn (winner-undo)
                (setq this-command 'winner-undo)))
        ((and (derived-mode-p 'term-mode)
              (require 'term)      ; for byte-compilation
              (term-in-char-mode)) ; <- macro expansion
         (term-send-raw-string "b"))
        (t ;else
         (progn (backward-word arg)
                (setq this-command 'backward-word)))))

;; Provide a simpler backwards zap-to-char (than prefixing with C-u -1)
(defun zap-to-char-backwards (arg char)
  (interactive "p\ncZap backwards to char: ")
  (zap-to-char (- arg) char))

;; Enable apply-macro-to-region-lines with named macros
(defun apply-named-macro-to-region-lines (top bottom)
  "Apply named keyboard macro to all lines in the region."
  (interactive "r")
  (let ((macro (intern
                (completing-read "kbd macro (name): "
                                 obarray
                                 (lambda (elt)
                                   (and (fboundp elt)
                                        (or (stringp (symbol-function elt))
                                            (vectorp (symbol-function elt))
                                            (get elt 'kmacro))))
                                 t))))
    (apply-macro-to-region-lines top bottom macro)))

;; Uniqify region (alternative to "C-u M-| uniq RET")
(defun uniquify-region ()
  "remove duplicate adjacent lines in the given region"
  (interactive)
  (narrow-to-region (region-beginning) (region-end))
  (goto-char (point-min))
  (while (re-search-forward "\\(.*\n\\)\\1+" nil t)
    (replace-match "\\1" nil nil))
  (widen)
  nil)

;; Uniqify region (alternative to "C-u M-| sort | uniq RET")
(defun uniquify-region-sorted ()
  "sort and remove duplicate lines in the given region"
  (interactive)
  (sort-lines nil (region-beginning) (region-end))
  (uniquify-region))

(defun sort-lines-case-insensitive (reverse beg end)
  "Call `sort-lines' with `sort-fold-case' non-nil."
  (interactive "P\nr")
  (let ((sort-fold-case t))
    (sort-lines reverse beg end)))

(defun sort-lines-case-sensitive (reverse beg end)
  "Call `sort-lines' with `sort-fold-case' nil."
  (interactive "P\nr")
  (let ((sort-fold-case nil))
    (sort-lines reverse beg end)))

;; Rename file and buffer together
(defun rename-file-and-buffer ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file name new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)))))))

;; Duplicate / clone the current line.
(defun clone-line (&optional arg)
  "Duplicate the line at point (arg times)."
  (interactive "*p")
  (save-excursion
    ;; The last line of the buffer cannot be killed
    ;; if it is empty. Instead, simply add a new line.
    (if (and (eobp) (bolp))
        (newline)
      ;; Otherwise kill the whole line, and yank it back.
      (let ((kill-read-only-ok t)
            deactivate-mark)
        (setq buffer-read-only t)
        (kill-whole-line)
        (setq buffer-read-only nil)
        (while (> arg 0)
          (yank)
          (setq arg (1- arg)))))))

;; Open a new line and indent.
(defun my-open-line-and-indent (n)
  "Like `newline-and-indent' for the `open-line' command."
  (interactive "*p")
  (let ((eol (copy-marker (line-end-position))))
    (open-line n)
    (indent-region (point) eol)
    (set-marker eol nil)))

;; Toggle between BOL and beginning of code
(defun my-beginning-of-line-or-indentation ()
  "Move to beginning of line, or indentation."
  (interactive)
  (if (bolp)
      (back-to-indentation)
    (beginning-of-line)))

(defun my-indent-rigidly (beginning end &optional arg)
  "Indent current line or active region ARG columns, using `indent-rigidly'.

If no argument is supplied, indent by `tab-width' columns."
  (interactive "r\nP")
  (unless (region-active-p)
    (setq beginning (line-beginning-position)
          end (line-end-position)))
  (indent-rigidly beginning end (if arg
                                    (prefix-numeric-value arg)
                                  tab-width)))

(defun my-capitalize-word (&optional arg)
  "Used to invoke capitalize-word despite subword-mode remappings."
  (interactive "*p")
  (capitalize-word arg))

;; Display non-critical messages with minimal interference.
(defun my-unimportant-notification (format-string &rest args)
  "Display a message temporarily, if/when minibuffer isn't active.
Also see the following:
`minibuffer-message'
`with-temp-message'
`minibuffer-message-timeout'"
  (my--unimportant-notification
   format-string args
   6 ;; seed the remaining attempts counter (maximum)
   5 ;; number of seconds to increase delay by when minibuffer is active
   ))

(defun my--unimportant-notification
  (format-string args attempts increment &optional delay total)
  "Private logic for \\[my-unimportant-notification]"
  (let ((delay (or delay 0))
        (total (or total 0)))
    (if (and (eq (selected-window) (minibuffer-window))
             (> attempts 0))   ; ^^ or: (minibufferp (current-buffer)) ?
                               ; and: (not cursor-in-echo-area) ?
                               ; see: (eldoc-display-message-no-interference-p)

        ;; if the minibuffer is active, then postpone the message by an
        ;; ever-increasing delay, until we exceed our available attempt
        ;; limit (at which point we display the message regardless).
        (let* ((delay (+ increment delay))
               (total (+ total delay)))
          (run-with-timer
           delay nil
           'my--unimportant-notification
           format-string args (1- attempts) increment delay total))
      ;; otherwise show the message
      (let* ((backup-message (current-message))
             (delay-message " (message delayed %d seconds)")
             (delay-arg (or (and (zerop total) "")
                            (format delay-message total)))
             (args (append args (list delay-arg) nil))
             (format-string (concat format-string "%s"))
             (tmp-message (apply 'format format-string args)))
        ;; show message briefly, then revert.
        (message tmp-message)
        (run-with-timer
         3 nil
         (lambda (tmp-message backup-message)
           ;; revert to the backup message, unless something
           ;; else has already over-written our temporary one
           (when (string= tmp-message (current-message))
             (message backup-message)))
         tmp-message
         backup-message)))))

(defvar reminder-handler 'frame
  "The default handler used by `reminder' if none is specified.

One of `frame' or `notification' or `zenity'.")

(defun reminder (what when &optional type timeout handler)
  "Remind me about something later.

WHAT is the text of the message.
WHEN is a time spec which depends on HANDLER or `reminder-handler'.

With an interactive prefix arg, also prompt for the remaining arguments:

TYPE should be one of `info' (default), `warning', `error', or `notification'.
TIMEOUT is a number of seconds (default is no timeout).
HANDLER is one of the symbols `frame', `notification', `zenity' (the default
is the value of `reminder-handler')."
  ;; Read arguments.
  (interactive
   (nconc
    (list (read-string "Remind me about: ")
          (read-string "Remind me at [date|time|time date|NOW]: "))
    (and current-prefix-arg
         (list (intern (completing-read
                        "Type (info): " '(info warning error notification)
                        nil t nil nil "info"))
               (let* ((str (read-string "Timeout in seconds (none): "))
                      (num (string-to-number str)))
                 (if (and (eql 0 num) (not (string= str "0")))
                     nil
                   num))
               (intern (completing-read
                        (format "Handler (%s): " reminder-handler)
                        '(frame notification zenity)
                        nil t nil nil
                        (symbol-name reminder-handler)))))))
  ;; Call handler.
  (unless handler
    (setq handler reminder-handler))
  (funcall (intern (concat "reminder--" (symbol-name handler)))
           what when type timeout))

(defun reminder--zenity (what when &optional type timeout)
  "Zenity-based handler for `reminder'.

The WHEN argument must be a valid \\='at\\=' timespec.  See man page `at(1)'."
  (interactive "sRemind me about: \nsRemind me at [date|time|time date|NOW]: ")
  (let ((buf (get-buffer-create " *reminder*"))
        (shell-command-dont-erase-buffer nil)
        (message-log-max nil))
    (shell-command
     (format "echo 'DISPLAY=%s zenity --%s%s --width=500 --title=Reminder --text='%s \
| at -M %s 2>&1 | grep -v \"warning: commands will be executed using /bin/sh\""
             (shell-quote-argument (getenv "DISPLAY"))
             (or type 'info)
             (if timeout (format " --timeout=%d" timeout) "")
             ;; Escape the text for the shell command which will be run by 'at',
             ;; as well as for the shell command we are running here.
             (shell-quote-argument (shell-quote-argument what))
             (shell-quote-argument (if (equal when "") "now" when)))
     buf " *reminder-errors*")))

(defun reminder--notification (what &optional _when type timeout)
  "Notification-based handler for `reminder'.  Does not support WHEN.

See URL `https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html'."
  (interactive "sRemind me about: ")
  (require 'notifications)
  (let ((args (list :title "Reminder"
                    :transient t ;; Important!
                    :body what)))
    ;; If the notification isn't `:transient' then Gnome will hold onto it
    ;; *even after it disappears from view*; and once it has a hard-coded total
    ;; of 20 such "unacknowledged" notifications hidden away behind the scenes,
    ;; it will refuse to allow any others to be delivered.  The fix for that is
    ;; to run gnome-panel (which initially has nothing helpful), hold Alt while
    ;; right-clicking that bar (how nice that regular right-click does nothing
    ;; at all while this gets you a menu), select "Add to panel", choose
    ;; "Notification area", and then interact with that new UI, which provides
    ;; a way to view and remove previous notifications.  Apparently the entire
    ;; notification system is wrapped up into some kind of "gnome applet" with
    ;; no CLI access at all.  Thanks Gnome.
    (setq args (append args (reminder--notification-type-args type)))
    (if timeout
        (setq args (append args (list :timeout (* 1000 timeout))))
      (setq args (append args (list :timeout 0))))
    ;; :replaces-id    The ID that this notification replaces.
    ;; :actions        A list of actions
    ;; :category       The type of notification this is.
    ;; :sound-file     The path to a sound file to play
    ;; :sound-name     https://specifications.freedesktop.org/sound-naming-spec/sound-naming-spec-latest.html#names
    ;;                 Some relevant examples are:
    ;;                 - "dialog-information"
    ;;                 - "dialog-warning"
    ;;                 - "dialog-error"
    ;;                 - "dialog-question"
    ;; :suppress-sound Suppress playing sounds, if able.
    ;; :on-action      Function to call when an action is invoked.
    ;; :on-close       Function to call when the notification is closed
    ;;                 by timeout or by the user.
    (apply #'notifications-notify args)))

(defun reminder--notification-type-args (type)
  "Return the TYPE-specific arguments for `reminder--notification'."
  (let ((icondir "/usr/share/icons/Humanity/status/128/")
        (args (cond ((eq type 'error)
                     '( :urgency critical
                        :app-icon "dialog-error.svg"
                        :sound-name "dialog-warning"))
                    ((eq type 'warning)
                     '( :urgency normal
                        :app-icon "dialog-warning.svg"
                        :sound-name "dialog-warning"))
                    (t
                     '( :urgency low
                        :app-icon "dialog-information.svg"
                        :sound-name "dialog-information")))))
    ;; Establish the path for the icon filename.
    (plist-put args :app-icon (expand-file-name
                               (plist-get args :app-icon) icondir))
    args))

;; FIXME: There is a race condition...
;;
;; If I am in the middle of typing when the frame pops up, and consequently type
;; something at the frame almost as soon as it appears, it somehow messes with
;; the 'q' key binding (maybe as a side effect of something else), and I have to
;; use C-x 5 0 to close the frame instead.
;;
;; I can't trivially reproduce this by running M-x reminder--frame and keeping
;; on typing, though... also the frame is not made visible until everything
;; else has been done, so how is this issue happening at all? :/
;;
;; Is it possible that the buffer-local `reminder--frame' isn't being set??
;; Next time this happens, check to see if the notification buffer has a
;; buffer-local value for that.
;;
;; Yes, it does:
;; reminder--frame is a variable defined in `my-utilities.el'.
;; Its value is #<frame Notification 0x56340887cd20>
;; Local in buffer *reminder*; global value is nil
;;
;; Ah, the issue is that `view-mode' is not enabled!
;; The custom `view-exit-action' was set, though.  So enabling the mode
;; manually and then typing 'q' did the job.

(define-derived-mode reminder-frame-mode nil "Reminder Frame"
  "Major mode for reminder buffers generated by `reminder--frame'."
  (view-mode 1)
  (visual-line-mode 1)
  (hl-line-mode -1)
  (setq-local global-hl-line-mode nil)
  (when (fboundp 'hl-sexp-mode)
    (hl-sexp-mode -1)
    (setq-local global-hl-sexp-mode nil)))

(defvar-local reminder--frame nil)
(defvar-local reminder--frame-timer nil)

;; TODO: I *think* I no longer need these test cases.

;; (reminder "one\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.  I may be conflating window-height and frame-height?  Needs work. `header-line-format' and `mode-line-format' each require a line, which is probably the + 2 immediately below??\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.)\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.  I may be conflating window-height and frame-height?  Needs work. `header-line-format' and `mode-line-format' each require a line, which is probably the + 2 immediately below??\nfive\nsix\nseven\neight\nnine\n> 10\none\ntwo\nthree\n" "now")

;; (reminder "one\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.  I may be conflating window-height and frame-height?  Needs work. `header-line-format' and `mode-line-format' each require a line, which is probably the + 2 immediately below??\nfive\nsix\nseven\neight\nnine\n> 10\none\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.  I may be conflating window-height and frame-height?  Needs work. `header-line-format' and `mode-line-format' each require a line, which is probably the + 2 immediately below??\nfive\nsix\nseven\neight\nnine\n> 10\none\ntwo\nthree\nfour: Needs more testing.  I'm getting a scrollbar when I'm using up the exact number of lines on display.  I think that was working before, so presumably it's a bug in the line-wrapping adjustments?  (although testing was without wrapped lines), and maybe that +1/+2 confusion I was having.  I may be conflating window-height and frame-height?  Needs work. `header-line-format' and `mode-line-format' each require a line, which is probably the + 2 immediately below??\nfive\nsix\nseven\neight\n\n\n" "now" 'error)

;; (reminder "one\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\n> 10" "now")

;; (reminder "one\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\n> 10" "now")

(defun reminder--frame (what &optional when type timeout)
  "Frame-based handler for `reminder'.

The WHEN argument must be a valid TIME for `run-at-time', or the string \"now\".
\(Note that when called interactively, WHEN will be a string.)"
  (interactive "sRemind me about: \nsRemind me at [date|time|time date|NOW]: ")
  (if (or (not when)
          (and (stringp when) (string= when "now")))
      (reminder--frame-1 what type timeout)
    (run-at-time when nil #'reminder--frame-1 what type timeout)))

(defun reminder--frame-1 (what type timeout)
  "Generates the frame for `reminder--frame'."
  (let ((buf (generate-new-buffer "*reminder*"))
        (important (memq type '(warning error)))
        (maxcol 0) (rowcount 0)
        (minwidth 70) (maxwidth 120)
        (minheight 9) (maxheight 40)
        width height pxwidth pxheight)
    (cl-destructuring-bind (fvscroll . fhscroll)
        (frame-current-scroll-bars)
      (with-current-buffer buf
        (let ((inhibit-read-only t))
          (erase-buffer)
          (reminder-frame-mode)
          (setq header-line-format "Reminder"
                mode-line-format '("" appt-mode-string)
                show-trailing-whitespace nil
                cursor-type 'hbar)
          (save-excursion
            (insert what)
            (skip-chars-backward " \n\t\r")
            (delete-region (point) (point-max))
            (goto-char (point-min))
            (while (not (eobp))
              (end-of-line)
              (setq maxcol (max maxcol (current-column)))
              (forward-line 1)
              (cl-incf rowcount))
            (setq width (max minwidth (min maxwidth maxcol))
                  ;; Add two rows (for the header line and mode line).
                  height (+ 2 (max minheight (min maxheight rowcount)))
                  ;; Added width/height pixels determined by trial-and-error.
                  ;; I don't know exactly what they are accounting for, and it
                  ;; seems odd that the number is odd; but nevertheless this
                  ;; is what got me the desired result.
                  pxwidth (+ 3 (* width (default-font-width)))
                  pxheight (+ 3 (* height (default-font-height)))))
          ;; Ensure that our `view-exit-action' will know which frame to
          ;; delete, even if the buffer is no longer being displayed in
          ;; a window at the time the custom function is called.
          (add-hook 'window-configuration-change-hook
                    (lambda ()
                      (unless reminder--frame
                        (setq reminder--frame (window-frame (selected-window)))))
                    nil :local)
          ;; The "q" key binding deletes the notification frame and
          ;; kills the buffer; but for important notifications the
          ;; user must manually delete the frame so that they cannot
          ;; ignore it by accident (i.e. dismissing the notification
          ;; it on autopilot).
          (if important
              (setq view-exit-action #'reminder--ding)
            (setq view-exit-action #'reminder--frame--kill-buffer-and-frame))
          ;; Handle the buffer being killed generally.
          (add-hook 'kill-buffer-hook #'reminder--frame--kill-buffer-and-frame
                    nil :local)
          ;; Handle the frame being deleted generally.
          (add-hook 'delete-frame-functions #'reminder--frame--delete-frame-handler
                    nil :local)
          ;; Create the notification.
          (let ((fparams
                 `((name . "Notification")
                   (visibility . nil)
                   (fullscreen . nil)
                   (auto-raise . t)
                   (sticky . t)
                   (menu-bar-lines . 0)
                   (tool-bar-lines . 0)
                   (tab-bar-lines . 0)
                   ;; (left-fringe . 0)
                   ;; (right-fringe . 0)
                   (vertical-scroll-bars . nil)
                   (horizontal-scroll-bars . nil)
                   (minibuffer . nil)
                   (width . (text-pixels . ,pxwidth)) ;; (width . ,width)
                   (height . (text-pixels . ,pxheight)) ;; (height . ,height)
                   (left . ,(- (/ (display-pixel-width) 2) (/ pxwidth 2)))
                   (top . ,(- (/ (display-pixel-height) 2) (/ pxheight 2)))
                   )))
            ;; Display a large border for important notifications.
            (when important
              (nconc fparams '((internal-border-width . 15))))
            ;; Make the invisible frame, adjust as necessary, and then display.
            (with-selected-frame (make-frame fparams)
              ;; Set the border colour to the foreground colour of the face for
              ;; the `type' of notification (`warning' or `error').
              (when important
                (let ((colour (face-attribute type :foreground nil 'default)))
                  (set-face-attribute 'internal-border (selected-frame)
                                      :background colour)))

              ;; Use a child frame for the new frame's minibuffer.
              ;; (info "(elisp) Frame Interaction Parameters")
              ;;
              ;; This is a funky way of getting the "no minibuffer" aesthetic
              ;; that I want for reminders, without the perils of pre-existing
              ;; frames ending up as minibuffer surrogates for the reminder
              ;; frame (which prevents the surrogate frame from being deleted
              ;; while the reminder exists).  The end result is something which
              ;; behaves like a regular frame but with the mini window visible
              ;; only when it's required.

              ;; FIXME: Should I be using the `child-frame' value here ??
              ;;
;; â€˜minibufferâ€™
;;      Whether this frame has its own minibuffer.  The value â€˜tâ€™ means
;;      yes, â€˜nilâ€™ means no, â€˜onlyâ€™ means this frame is just a minibuffer.
;;      If the value is a minibuffer window (in some other frame), the
;;      frame uses that minibuffer.
;;
;;      This parameter takes effect when the frame is created.  If
;;      specified as â€˜nilâ€™, Emacs will try to set it to the minibuffer
;;      window of â€˜default-minibuffer-frameâ€™ (*note Minibuffers and
;;      Frames::).  For an existing frame, this parameter can be used
;;      exclusively to specify another minibuffer window.  It is not
;;      allowed to change it from a minibuffer window to â€˜tâ€™ and
;;      vice-versa, or from â€˜tâ€™ to â€˜nilâ€™.  If the parameter specifies a
;;      minibuffer window already, setting it to â€˜nilâ€™ has no effect.
;;
;;      The special value â€˜child-frameâ€™ means to make a minibuffer-only
;;      child frame (*note Child Frames::) whose parent becomes the frame
;;      created.  As if specified as â€˜nilâ€™, Emacs will set this parameter
;;      to the minibuffer window of the child frame but will not select the
;;      child frame after its creation.

              (let ((miniframe (make-frame `((parent-frame . ,(selected-frame))
                                             (minibuffer . only)
                                             (minibuffer-exit . t)
                                             (visibility . nil)
                                             (height . 1)))))
                (set-frame-parameter miniframe 'top '(- 0))
                (cl-flet ((hide () (set-frame-parameter miniframe 'visibility nil)))
                  (add-hook 'echo-area-clear-hook #'hide nil :local))
                ;; Make the child frame contain the minibuffer for the parent.
                (set-frame-parameter nil 'minibuffer (minibuffer-window
                                                      miniframe)))
              ;; FIXME: How can that ^ result in the following?!:
              ;; It's a selected minibuffer-only frame... the window
              ;; can surely only be "a valid minibuffer window".
              ;;
              ;; Now Trying (minibuffer-window miniframe) instead...
              ;;
;; Debugger entered--Lisp error: (error "The `minibuffer' parameter does not specify a valid minibuffer window")
;;   (modify-frame-parameters nil ((minibuffer . #<window 8499 on *reminder*<14>>)))
;;   (set-frame-parameter nil minibuffer #<window 8499 on *reminder*<14>>)
;;   (reminder--frame-1 #("13 mins: 18:30 [board games] Welcome Wednesday" 0 9 (face warning)) info 300)
;;   (reminder--frame #("13 mins: 18:30 [board games] Welcome Wednesday" 0 9 (face warning)) "now" info 300)
;;   (reminder #("13 mins: 18:30 [board games] Welcome Wednesday" 0 9 (face warning)) "now" info 300)
;;   (let* ((now nil) (soon nil) (text (let ((temp-buffer (generate-new-buffer " *temp*" t))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (let ((--dolist-tail-- min-to-app)) (while --dolist-tail-- (let ((eta (car --dolist-tail--))) (insert (if (equal eta "0") (prog1 (propertize "NOW: " 'face 'error) (setq now t)) (let ((fstr (if (string= eta "1") "%s min: " "%s mins: "))) (prog1 (propertize (format fstr eta) 'face (if (<= (string-to-number eta) 15) 'warning 'diary-time)) (if (<= (string-to-number eta) appt-display-interval) (progn (setq soon t)))))) (string-trim (car-safe (prog1 appt-msg (setq appt-msg (cdr appt-msg))))) (if appt-msg my-appt-disp-window-separator "")) (setq --dolist-tail-- (cdr --dolist-tail--))))) (goto-char (point-min)) (while (search-forward "\n " nil 'noerror) (replace-match "\n")) (buffer-string)) (and (buffer-name temp-buffer) (kill-buffer temp-buffer))))))) (reminder text "now" (if now 'error (if soon 'warning 'info)) (if now nil (* 60 appt-display-interval))))
;;   (my-appt-disp-window "13" "Wed Jul 12 " "18:30 [board games] Welcome Wednesday ")
;;   (appt-display-message ("18:30 [board games] Welcome Wednesday ") (13))
;;   (appt-check)
;;   (apply appt-check nil)
;;   (timer-event-handler [t 25774 17816 0 60 appt-check nil nil 0 t])

              ;; Adjust the parent frame
              (when (<= rowcount maxheight)
                ;; Wrapped lines may have caused us to miscalculate the required
                ;; height for the window, so check how many lines we're actually
                ;; using at the established width, and make any necessary
                ;; adjustments before making the frame visible.
                (let* ((screenlines (+ 0 (count-screen-lines (point-min)
                                                             (point-max))))
                       ;; Visible screenlines.
                       (vislines (min screenlines maxheight))
                       ;; Add two rows (for the header line and mode line).
                       (sheight (+ 2 vislines)))
                  (when (> sheight (window-height))
                    (setq pxheight (+ 3 (* sheight (default-font-height))))
                    (set-frame-parameter nil 'height (cons 'text-pixels pxheight))
                    (set-frame-parameter nil 'top (- (/ (display-pixel-height) 2)
                                                     (/ pxheight 2))))
                  (when (> screenlines maxheight)
                    (set-frame-parameter nil 'vertical-scroll-bars 'right))
                  ;; Centre the text if appropriate.
                  (when (< vislines minheight)
                    (let ((margin (/ (- minheight vislines) 2)))
                      (open-line margin)))
                  (when (< maxcol minwidth)
                    (let ((margin (/ (- minwidth maxcol) 2)))
                      ;; (setq left-margin-width margin
                      ;;       right-margin-width margin)
                      (indent-rigidly (point-min) (point-max) margin)))))
              ;; Adjust for scroll bars.
              (if (<= rowcount maxheight)
                  ;; Avoid scrolling if the entire buffer is visible.
                  (setq-local next-screen-context-lines 0)
                (when fvscroll
                  (set-frame-parameter nil 'vertical-scroll-bars fvscroll)
                  (setq pxwidth (+ pxwidth (frame-scroll-bar-width)))
                  (set-frame-parameter nil 'width (cons 'text-pixels pxwidth))
                  (set-frame-parameter nil 'left (- (/ (display-pixel-width) 2)
                                                    (/ pxwidth 2)))))
              (when (and fhscroll (> maxcol maxwidth))
                (set-frame-parameter nil 'horizontal-scroll-bars fhscroll)
                (setq pxheight (+ pxheight (frame-scroll-bar-height)))
                (set-frame-parameter nil 'height (cons 'text-pixels pxheight))
                (set-frame-parameter nil 'top (- (/ (display-pixel-height) 2)
                                                 (/ pxheight 2))))
              ;; Make the frame's initial window dedicated to the reminder buffer.
              (set-window-dedicated-p (selected-window) t)
              ;; Handle the TIMEOUT argument.
              (when timeout
                (setq-local reminder--frame-timer
                            (run-with-timer timeout nil (lambda (frm buf)
                                                          (delete-frame frm)
                                                          (kill-buffer buf))
                                            (selected-frame)
                                            buf)))
              ;; Make the frame visible.
              (set-frame-parameter nil 'visibility t))))))))

(defun reminder--ding (buf)
  "Flash the reminder frame."
  (with-current-buffer buf
    (let ((visible-bell t)
          (ring-bell-function nil))
      (ding))
    (view-mode 1)))

(defun reminder--frame--kill-buffer-and-frame (&optional buf)
  "Kill the reminder frame and buffer, and tidy up.

Used with the buffer argument BUF for `view-exit-action', and
with no argument for `kill-buffer-hook'."
  ;; If BUF is non-nil and has already been killed, do nothing.
  (unless (and buf (not (buffer-live-p buf)))
    (with-current-buffer (or buf (current-buffer))
      (when (timerp reminder--frame-timer)
        (cancel-timer reminder--frame-timer))
      (when (frame-live-p reminder--frame)
        (set-frame-parameter reminder--frame 'visibility nil)
        (redisplay)
        ;; (reminder--frame--delete-miniframe reminder--frame)
        (delete-frame reminder--frame)))
        ;; FIXME: Error during redisplay: (run-hook-with-args
        ;; reminder--frame--delete-frame-handler #<frame Notification
        ;; 0x5584b4f29370>) signaled (error "Lisp nesting exceeds
        ;; `max-lisp-eval-depth'")
    (when (and buf (buffer-live-p buf))
      (remove-hook 'kill-buffer-hook
                   #'reminder--frame--kill-buffer-and-frame :local)
      (kill-buffer buf))))

(defvar reminder--frame--delete-frame-handler)
(defun reminder--frame--delete-frame-handler (frm)
  "Kill the reminder buffer, and tidy up.

Used in `delete-frame-functions'."
  ;; If FRM is non-nil and has already been killed, do nothing.
  (when (frame-live-p frm)
    (unless (bound-and-true-p reminder--frame--delete-frame-handler)
      (let ((reminder--frame--delete-frame-handler t))
        (with-selected-frame frm
          ;; Delete the miniframe, if any.
          (reminder--frame--delete-miniframe frm)
          ;; Kill reminder buffers in the selected frame.
          (walk-windows
           (lambda (win)
             (with-selected-window win
               (when (eq reminder--frame frm)
                 (when (timerp reminder--frame-timer)
                   (cancel-timer reminder--frame-timer))
                 (remove-hook 'kill-buffer-hook
                              #'reminder--frame--kill-buffer-and-frame :local)
                 (kill-buffer))))))))))

;; FIXME: Apparently [...? what was I going to say?  Maybe I'll find out...]
;;
;; (I think it was to do with not being able to delete other frames because
;; they had become unintentional surrogate minibuffers for things which I
;; didn't expect to still be live.  Bah.  So annoying!)
(defun reminder--frame--delete-miniframe (frm)
  "Delete the miniframe for frame FRM, if any."
  (when (frame-live-p frm)
    (when-let* ((miniwindow (frame-parameter frm 'minibuffer))
                (windowframe (and (windowp miniwindow)
                                  (window-frame miniwindow)))
                (miniframe (and (frame-live-p windowframe)
                                (not (eq windowframe frm))
                                windowframe)))
      (set-frame-parameter frm 'minibuffer t)
      (delete-frame miniframe))))

(add-hook 'reminder-frame-mode-hook 'my-reminder-frame-mode-hook)
(defun my-reminder-frame-mode-hook ()
  "Custom `reminder-frame-mode' behaviours."
  (goto-address-mode 1)
  (when (fboundp 'my-bug-reference-mode-enable)
    (my-bug-reference-mode-enable)))

(defun my-interactive-ding ()
  (interactive)
  (ding))

;; Convert file's EOL style to Unix
(defun to-unix-eol (fpath)
  "Change file's line ending to unix convention."
  (let (mybuffer)
    (setq mybuffer (find-file fpath))
    (set-buffer-file-coding-system 'unix) ; or 'mac or 'dos
    (save-buffer)
    (kill-buffer mybuffer)))

;; Bulk-convert EOL style to Unix (for marked files in Dired).
(defun dired-2unix-marked-files ()
  "Change to unix line ending for marked (or next arg) files."
  (interactive)
  (mapc 'to-unix-eol (dired-get-marked-files)))

;; pop-to-mark-command in the opposite direction
;; around the local mark-ring
(defun unpop-to-mark-command ()
  "Unpop off mark ring into the buffer's actual mark.
Does not set point.  Does nothing if mark ring is empty."
  (interactive)
  (let ((num-times
         (if (equal last-command 'pop-to-mark-command) 2 1
           ;; (if (equal last-command 'unpop-to-mark-command) 1
           ;;   (error "Previous command was not a (un)pop-to-mark-command"))
           )))
    (dotimes (_ num-times)
      (when mark-ring
        (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
        (set-marker (mark-marker) (+ 0 (car (last mark-ring))) (current-buffer))
        (when (null (mark t)) (ding))
        (setq mark-ring (nbutlast mark-ring))
        (goto-char (mark t)))
      (deactivate-mark))))

(defmacro activate-my-unpop-to-mark-advice ()
  "Enable reversing direction with un/pop-to-mark."
  `(defadvice ,(key-binding (kbd "C-SPC"))
     (around my-unpop-to-mark-advice activate)
     "Unpop-to-mark with negative arg"
     (let* ((arg (ad-get-arg 0))
            (num (prefix-numeric-value arg)))
       (cond
        ;; Enabled repeated un-pops with C-SPC
        ((eq last-command 'unpop-to-mark-command)
         (if (and arg (> num 0) (<= num 4))
             ad-do-it ;; C-u C-SPC reverses back to normal direction
           ;; Otherwise continue to un-pop
           (setq this-command 'unpop-to-mark-command)
           (unpop-to-mark-command)))
        ;; Negative argument un-pops: C-- C-SPC
        ((< num 0)
         (setq this-command 'unpop-to-mark-command)
         (unpop-to-mark-command))
        (t
         ad-do-it)))))
(activate-my-unpop-to-mark-advice)

;; Kill ring / Yank assistance
(defun my-yank-menu ()
  "Select text to yank from a pop-up menu of recently killed items."
  (interactive)
  (popup-menu 'yank-menu))

(when (require 'browse-kill-ring nil 'noerror)
  ;; Either...
  ;; make it the default behaviour:
  ;;(browse-kill-ring-default-keybindings)
  ;;
  ;; or use a custom key binding:
  (global-set-key (kbd "C-c k") 'browse-kill-ring)
  )

;; Make M-y re-yank the most-recently-yanked text if the previous
;; command was NOT a yank. This prevents the gradual burying of the
;; desired text in the kill ring, when you wish to kill several
;; pieces of text, but yank the same thing in as a replacement.
;; @see; http://stackoverflow.com/a/5825012/324105
(defun jp/yank (&optional arg)
  "Perform a `yank' and save the text to the jp/yank register."
  (interactive)
  (set-register 'jp/yank (current-kill 0 t))
  (yank arg))

(defun jp/yank-pop (&optional arg)
  "If `yank-pop' fails, insert jp/yank register contents instead."
  (interactive)
  (condition-case nil
      (yank-pop arg)
    (error (insert (get-register 'jp/yank)))))

;; Write a copy of the current buffer or region to a file.
(defun my-write-copy-to-file ()
  "Write a copy of the current buffer or region to a file."
  (interactive)
  (let* ((curr (buffer-file-name))
         (new (read-file-name
               "Copy to file: " nil nil nil
               (and curr (file-name-nondirectory curr))))
         (mustbenew (if (and curr (file-equal-p new curr)) 'excl t)))
    (if (use-region-p)
        (write-region (region-beginning) (region-end) new nil nil nil mustbenew)
      (save-restriction
        (widen)
        (write-region (point-min) (point-max) new nil nil nil mustbenew)))))

;; Grab copy of the current buffer's filename.
(defun my-copy-buffer-file-name (&optional arg)
  "Copy the buffer's filename to the kill ring.
With a prefix arg, use the file's truename."
  (interactive "P")
  (let ((filename (if arg
                      (file-truename (buffer-file-name))
                    (buffer-file-name))))
    (if (not filename)
        (message "No buffer filename")
      (message filename)
      (kill-new filename))))

(defun my-dired-jump (arg)
  "Like `dired-jump', but a single (C-u) prefix arg means \"replace the
current buffer with the target dired buffer\" (i.e. kill the original
buffer). A double (C-u C-u) prefix argument triggers the normal prefix
argument behaviour of `dired-jump'."
  (interactive "P")
  (require 'dired-x)
  (cond
   ((equal arg '(4))
    (let ((origin (current-buffer))
          (current-prefix-arg nil))
      (call-interactively 'dired-jump)
      (kill-buffer origin)))
   ((equal arg '(16))
    (let ((current-prefix-arg '(4)))
      (call-interactively 'dired-jump)))
   (t
    (call-interactively 'dired-jump))))

(defun my-parent-of-dir-in-buffer-file-name (dir)
  "Return the path to the parent of the named directory (arg),
within the current buffer-file-name."
  (let* ((bfn-list (split-string (buffer-file-name) "/"))
         (dir-list (reverse (cdr (member dir (reverse bfn-list))))))
    (when dir-list
      (mapconcat 'identity dir-list "/"))))

(defun my-directory-files (directory &optional full match nosort)
  "Like `directory-files', but excluding \".\" and \"..\"."
  (let ((files (cons nil (directory-files directory full match nosort))))
    (let ((parent files)
          (current (cdr files))
          (exclude (list "." ".."))
          (file nil))
      (while (and current exclude)
        (setq file (car current))
        (if (not (member file exclude))
            (setq parent current)
          (setcdr parent (cdr current))
          (setq exclude (delete file exclude)))
        (setq current (cdr current)))
      (cdr files))))

(defun my-before-save-create-directory-maybe ()
  "Offer to create the file's parent directories, if they do not exist."
  (let ((dir (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p dir))
               (y-or-n-p (format "Directory %s does not exist. Create it? " dir)))
      (make-directory dir t))))

;; Add a 'F'ind marked files keybinding to dired
(with-eval-after-load "dired"
  ;; my-dired-find-file
  (define-key dired-mode-map (kbd "F") 'my-dired-find-file)
  (defun my-dired-find-file (&optional arg)
    "Open each marked file, or the file at point, or the next ARG files."
    (interactive "P")
    (let* ((fn-list (dired-get-marked-files nil arg)))
      (mapc 'find-file fn-list)))

  ;; my-dired-create-file
  (define-key dired-mode-map (kbd "_") 'my-dired-create-file)
  (defun my-dired-create-file (file)
    "Create a file called FILE.
    If FILE already exists, signal an error."
    (interactive
     (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
           (try expanded)
           (dir (directory-file-name (file-name-directory expanded)))
           new)
      (if (file-exists-p expanded)
          (error "Cannot create file %s: file exists" expanded))
      ;; Find the topmost nonexistent parent dir (variable `new')
      (while (and try (not (file-exists-p try)) (not (equal new try)))
        (setq new try
              try (directory-file-name (file-name-directory try))))
      (when (not (file-exists-p dir))
        (make-directory dir t))
      (write-region "" nil expanded t)
      (when new
        (dired-add-file new)
        (dired-move-to-filename))))
  ) ;; end of with-eval-after-load "dired"

(defun my-find-iname-grep-dired (dir pattern regexp)
  "`find-grep-dired' with additional file-name pattern argument."
  (interactive
   "DFind-name (directory): \nsFind-name (filename wildcard): \nsFind-grep (grep regexp): ")
  (find-dired dir (concat "-iname " (shell-quote-argument pattern) " "
                          "-type f -exec " grep-program " " find-grep-options " -e "
                          (shell-quote-argument regexp) " "
                          (shell-quote-argument "{}") " "
                          (shell-quote-argument ";"))))

(defvar my-shell-command-to-dired-history '("ls -al"))
(defun my-shell-command-to-dired (cmd)
  "Invoke `dired-virtual-mode' on the output of shell command CMD.

The shell command's output format must be equivalent to that of \"ls -al\"."
  (interactive
   (list (read-from-minibuffer
          (format "Shell command (%s): "
                  (car my-shell-command-to-dired-history))
          nil nil nil 'my-shell-command-to-dired-history)))
  (when (string= "" cmd)
    (setq cmd (or (car my-shell-command-to-dired-history)
                  "ls -al")))
  (let ((buf (get-buffer-create (format "*Dired: %S*" cmd))))
    (shell-command cmd buf)
    (with-current-buffer buf
      (dired-virtual-mode)
      (pop-to-buffer buf))))


;; Add a non-regexp `dired-do-query-replace-regexp' equivalent.
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "C-c Q") 'my-dired-do-query-replace))

(defun my-dired-do-query-replace (from to &optional delimited)
  "Do `query-replace' of FROM with TO, on all marked files.
As each match is found, the user must type a character saying
what to do with it.  Type SPC or `y' to replace the match,
DEL or `n' to skip and go to the next match.  For more directions,
type \\[help-command] at that time.

Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit the query-replace loop (\\[keyboard-quit], RET or q), you can
resume the query replace with the command \\[fileloop-continue]."
  (interactive
   (let ((common
	  (query-replace-read-args
           "Query replace in marked files" t t)))
     (list (nth 0 common) (nth 1 common) (nth 2 common))))
  (dolist (file (dired-get-marked-files nil nil #'dired-nondirectory-p nil t))
    (let ((buffer (get-file-buffer file)))
      (if (and buffer (with-current-buffer buffer
			buffer-read-only))
	  (error "File `%s' is visited read-only" file))))
  (fileloop-initialize-replace
   (regexp-quote from) to
   (dired-get-marked-files nil nil #'dired-nondirectory-p)
   (if (equal from (downcase from)) nil 'default)
   delimited)
  (fileloop-continue))

(defun my-tags-query-replace (from to &optional delimited files)
  "Do `query-replace' of FROM with TO on all files listed in tags table.
Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit (\\[keyboard-quit], RET or q), you can resume the query replace
with the command \\[fileloop-continue].

As each match is found, the user must type a character saying
what to do with it.  Type SPC or `y' to replace the match,
DEL or `n' to skip and go to the next match.  For more directions,
type \\[help-command] at that time.

For non-interactive use, this is superseded by `fileloop-initialize-replace'."
  (interactive (query-replace-read-args "Tags query replace" t t))
  (fileloop-initialize-replace
   (regexp-quote from) to
   (tags--compat-files (or files t))
   (if (equal from (downcase from)) nil 'default)
   delimited)
  (fileloop-continue))

(defun my-replace-regexp-group (from to group)
  "In all matches for regexp FROM, replace the content of GROUP with TO."
  (interactive "sFrom: \nsTo: \nnGroup: ")
  (while (re-search-forward from nil t)
    (replace-match to nil nil nil group)))

;; Toggle between a vertical and horizontal window split
(defun toggle-window-split ()
  (interactive)
  (when (= (count-windows) 2)
    (let* ((this-win-buffer (window-buffer))
           (next-win-buffer (window-buffer (next-window)))
           (this-win-edges (window-edges (selected-window)))
           (next-win-edges (window-edges (next-window)))
           (this-win-2nd (not (and (<= (car this-win-edges)
                                       (car next-win-edges))
                                   (<= (cadr this-win-edges)
                                       (cadr next-win-edges)))))
           (splitter
            (if (= (car this-win-edges)
                   (car (window-edges (next-window))))
                'split-window-horizontally
              'split-window-vertically)))
      (delete-other-windows)
      (let ((first-win (selected-window)))
        (funcall splitter)
        (when this-win-2nd (other-window 1))
        (set-window-buffer (selected-window) this-win-buffer)
        (set-window-buffer (next-window) next-win-buffer)
        (select-window first-win)
        (when this-win-2nd (other-window 1))))))

(defun my-split-window-below (&optional arg)
  "Split the current window 50/50 by default.
A single-digit prefix argument gives the top window arg * 10%
of the available lines."
  (interactive "P")
  (let* ((proportion (and arg (* arg 0.1)))
         (size (and proportion (round (* proportion (window-height))))))
    (split-window-below size)))

;; Toggle window dedication
(defun toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message (if (let* ((window (selected-window))
                      (toggle (not (window-dedicated-p window))))
                 (set-window-dedicated-p window toggle))
               "Window '%s' is dedicated"
             "Window '%s' is normal")
           (current-buffer)))

(defun my-new-buffer-to-other-window ()
  "Relocate the current buffer to the other window."
  (interactive)
  (let ((buf (current-buffer)))
    (switch-to-buffer (other-buffer (current-buffer)))
    (other-window 1)
    (switch-to-buffer buf)))

(defun my-relocate-buffer ()
  "Move the current buffer to a different window.

Intended for use when a buffer gets displayed in the \\='wrong\\='
window, in order to move it to the preferred window without
otherwise disturbing the pre-existing window configuration.

The target window is selected using `ace-window'.

The buffer is buried first, so that the original window can
acquire whichever buffer it had been displaying previously."
  (interactive)
  (require 'ace-window)
  (aw-select " - Relocate to target window"
             (lambda (win)
               (let ((buf (current-buffer)))
                 (bury-buffer)
                 (select-window win)
                 (switch-to-buffer buf nil :force)))))

;;
;; Ediff the current buffer's file with its auto-saved backup file.
;;
(defun ediff-auto-save ()
  "Compare the current buffer's file with its auto-saved backup file."
  (interactive)
  (let ((auto-file-name (make-auto-save-file-name))
        (file-major-mode major-mode))
    (ediff-files buffer-file-name auto-file-name)
    (switch-to-buffer-other-window (file-name-nondirectory auto-file-name))
    (apply file-major-mode '())
    (other-window 1))) ;; back to ediff panel

;;
;; Diff the current buffer with the file contents
;;
(defun my-diff-buffer-with-file ()
  "Compare the current modified buffer with the saved version."
  (interactive)
  (let ((diff-switches "-u")) ;; unified diff
    (diff-buffer-with-file (current-buffer))))

;;(defun ediff-file-with-buffer (file-A buf-B &optional startup-hooks job-name merge-buffer-file)
;;  (let (buf-A buf-C)
;;    (message "Reading file %s ... " file-A)
;;    ;;(sit-for 0)
;;    (ediff-find-file 'file-A 'buf-A 'ediff-last-dir-A 'startup-hooks)
;;    (ediff-setup buf-B file-B
;;       startup-hooks
;;       (list (cons 'ediff-job-name job-name))
;;       merge-buffer-file)))
;;
;; see defun ediff-setup (ediff-utils.el)
;; see defun ediff-files-internal (ediff.el)


;; By default, `ediff' is an alias for `ediff-files' in `ediff.el'.
(defalias 'ediff 'my-ediff-dwim)
(defun my-ediff-dwim ()
  "Do what I mean, when invoking `ediff'.

If there is an active region, call `ediff-regions-wordwise'.

Else if the current frame has 2 windows,
- Do `ediff-files' if the buffers are associated to files and the buffers
  have not been modified.
- Do `ediff-buffers' for the two buffers, otherwise.

Otherwise call `ediff-buffers' interactively."
  ;; Adapted from: http://kaushalmodi.github.io/2015/03/09/do-ediff-as-i-mean/
  (interactive)
  (if (region-active-p)
      (call-interactively 'ediff-regions-wordwise)
    (if (= 2 (safe-length (window-list)))
        (let* ((bufa (get-buffer (buffer-name)))
               (filea (buffer-file-name bufa))
               (bufb (save-excursion
                       (other-window 1)
                       (get-buffer (buffer-name))))
               (fileb (buffer-file-name bufb)))
          (if (or
               ;; if either of the buffers is not associated to a file
               (null filea) (null fileb)
               ;; if either of the buffers is modified
               (buffer-modified-p bufa) (buffer-modified-p bufb))
              (progn
                (message "Running (ediff-buffers \"%s\" \"%s\") .." bufa bufb)
                (ediff-buffers bufa bufb))
            (progn
              (message "Running (ediff-files \"%s\" \"%s\") .." filea fileb)
              (ediff-files filea fileb))))
      (call-interactively 'ediff-buffers))))

(defvar compare-windows-highlight)
(defun my-compare-windows-complete (&optional ignore-whitespace)
  "Highlight all differences between two windows.

With a prefix argument, do not highlight whitespace-only differences.
\(This does not prevent the highlighting of whitespace that is part of
a difference which includes non-whitespace characters.)

To remove the highlighting, use \\[compare-windows-dehighlight]."
  (interactive "P")
  (require 'cl-lib)
  (require 'compare-w)
  (compare-windows-dehighlight)
  (let ((w1 (get-buffer-window))
        (w2 (funcall compare-windows-get-window-function)))
    (cl-letf ((w1p (window-point w1))
              (w2p (window-point w2))
              (compare-windows-highlight 'persistent)
              ((symbol-function 'compare-windows-dehighlight) #'ignore)
              ((symbol-function 'ding) (lambda () (error "done"))))
      (with-selected-window w1
        (goto-char (point-min)))
      (with-selected-window w2
        (goto-char (point-min)))
      (ignore-errors
        (while (compare-windows ignore-whitespace)))
      ;; Highlight any non-matching remainder in both buffers.
      (let ((b1 (window-buffer w1))
            (b2 (window-buffer w2))
            (p1 (window-point w1))
            (p2 (window-point w2))
            (max1 (with-selected-window w1 (point-max)))
            (max2 (with-selected-window w2 (point-max))))
        (compare-windows-highlight p1 max1 b1 w1 p2 max2 b2 w2))
      (set-window-point w1 w1p)
      (set-window-point w2 w2p))))

;; (defadvice kill-buffer (around my-kill-buffer-check activate)
;;   "Prompt when a buffer is about to be killed."
;;   (let* ((buffer-file-name (buffer-file-name))
;;          backup-file)
;;     ;; see 'backup-buffer
;;     (if (and (buffer-modified-p)
;;              buffer-file-name
;;              (file-exists-p buffer-file-name)
;;              (setq backup-file (car (find-backup-file-name buffer-file-name))))
;;         (let ((answer (completing-read (format "Buffer modified %s, (d)iff, (s)ave, (k)ill? " (buffer-name))
;;                                        '("d" "s" "k") nil t)))
;;           (cond ((equal answer "d")
;;                  (set-buffer-modified-p nil)
;;                  (let ((orig-buffer (current-buffer))
;;                        (file-to-diff (if (file-newer-than-file-p buffer-file-name backup-file)
;;                                          buffer-file-name
;;                                        backup-file)))
;;                    (set-buffer (get-buffer-create (format "%s last-revision" (file-name-nondirectory file-to-diff))))
;;                    (buffer-disable-undo)
;;                    (insert-file-contents file-to-diff nil nil nil t)
;;                    (set-buffer-modified-p nil)
;;                    (setq buffer-read-only t)
;;                    (ediff-buffers (current-buffer) orig-buffer)))
;;                 ((equal answer "k")
;;                  (set-buffer-modified-p nil)
;;                  ad-do-it)
;;                 (t
;;                  (save-buffer)
;;                  ad-do-it)))
;;       ad-do-it)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Improved alternative to backward-up-list
(defun backward-up-sexp (arg)
  (interactive "p")
  (let ((ppss (syntax-ppss)))
    (cond ((elt ppss 3)
           (goto-char (elt ppss 8))
           (backward-up-sexp (1- arg)))
          ((backward-up-list arg)))))

(global-set-key [remap backward-up-list] 'backward-up-sexp)


(defun my-semnav-up (arg)
  "Helper for `my-extend-selection'
By Nikolaj Schumacher, 2008-10-20. Licensed under GPL."
  (interactive "p")
  (when (nth 3 (syntax-ppss))
    (if (> arg 0)
        (progn
          (skip-syntax-forward "^\"")
          (goto-char (1+ (point)))
          (cl-decf arg))
      (skip-syntax-backward "^\"")
      (goto-char (1- (point)))
      (cl-incf arg)))
  (up-list arg))

;; Include any header comment when using narrow-to-defun
(defun my-narrow-to-defun ()
  (interactive)
  ;; Allow point to be within a leading comment.
  (save-excursion
    (let ((cstart (comment-beginning)))
      (when cstart
        (goto-char cstart)))
    (while (comment-forward))
    (narrow-to-defun)) ;; Default behaviour.
  (when (buffer-narrowed-p)
    (save-excursion
      (let ((min (point-min))
            (max (point-max)))
        (goto-char min)
        (widen)
        ;; If there's a preceding comment.
        (when (forward-comment -1)
          ;; Skip back over ALL preceding comments & whitespace.
          (while (forward-comment -1))
          ;; Skip forwards over any page delimiters within those comments.
          (when (and page-delimiter (not (string= page-delimiter "")))
            (while (re-search-forward page-delimiter min t)))
          ;; Skip past any blank lines.
          (skip-chars-forward "[:space:]\n")
          (beginning-of-line)
          ;; This is the new point to narrow from.
          (setq min (point)))
        (narrow-to-region min max)))))

(defun my-narrow-to-region-indirect (start end)
  "`narrow-to-region' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive "r")
  (deactivate-mark)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-region start end))
    (pop-to-buffer buf)))

(defun my-narrow-to-page-indirect (&optional arg)
  "`narrow-to-page' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive "P")
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (narrow-to-page arg))
    (pop-to-buffer buf)))

(defun my-narrow-to-defun-indirect (&optional _arg)
  "`narrow-to-defun' in a cloned indirect buffer in the other window.

See `clone-indirect-buffer'."
  (interactive)
  (let ((buf (clone-indirect-buffer nil nil)))
    (with-current-buffer buf
      (my-narrow-to-defun)) ; _arg
    (pop-to-buffer buf)))

(defun my-extend-selection (arg &optional incremental)
  "Mark the symbol surrounding point.
Subsequent calls mark higher levels of sexps.
By Nikolaj Schumacher, 2008-10-20. Licensed under GPL."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     (or (and transient-mark-mode mark-active)
                         (eq last-command this-command))))
  (if incremental
      (progn
        (my-semnav-up (- arg))
        (forward-sexp)
        (mark-sexp -1))
    (if (> arg 1)
        (my-extend-selection (1- arg) t)
      (if (looking-at "\\=\\(\\s_\\|\\sw\\)*\\_>")
          (goto-char (match-end 0))
        (unless (memq (char-before) '(?\) ?\"))
          (forward-sexp)))
      (mark-sexp -1))))

(defun my-copy-region-unindented (pad beginning end &optional func)
  "Copy the region, un-indented by the length of its minimum indent.

If numeric prefix argument PAD is supplied, indent the resulting
text by that amount.

If FUNC is supplied, it will be called in the temporary buffer
with the unindented contents before the buffer is killed, rather
than copying those contents to the kill ring."
  (interactive "P\nr")
  (let ((buf (current-buffer))
        (itm indent-tabs-mode)
        (tw tab-width)
        (st (syntax-table))
        (indent nil))
    (with-temp-buffer
      (setq indent-tabs-mode itm
            tab-width tw)
      (set-syntax-table st)
      (insert-buffer-substring buf beginning end)
      ;; Establish the minimum level of indentation.
      (goto-char (point-min))
      (while (and (re-search-forward "^[[:space:]\n]*" nil :noerror)
                  (not (eobp)))
        (let ((length (current-column)))
          (when (or (not indent) (< length indent))
            (setq indent length)))
        (forward-line 1))
      (if (not indent)
          (error "Region is entirely whitespace")
        ;; Un-indent the buffer contents by the length of the minimum
        ;; indent level, and copy to the kill ring.
        (when pad
          (setq indent (- indent (prefix-numeric-value pad))))
        (indent-rigidly (point-min) (point-max) (- indent))
        (if func
            (funcall func)
          (copy-region-as-kill (point-min) (point-max)))))))

(defun my-copy-region-as-kill (pad beginning end)
  "Like `copy-region-as-kill' or, with prefix arg, `my-copy-region-unindented'.

\\[universal-argument] causes minimal indentation for the copied region.

A numeric prefix argument pads the minimal indent by PAD columns.

See also `my-kill-region'."
  (interactive "P\nr")
  (if pad
      (my-copy-region-unindented (if (consp pad) nil pad)
                                 beginning end)
    (copy-region-as-kill beginning end))
  ;; Use the `indicate-copied-region' feature from `kill-ring-save'.
  (if (called-interactively-p 'interactive)
      (indicate-copied-region)))

(defun my-kill-region (pad beginning end)
  "Like `kill-region'.  With prefix arg, also `my-copy-region-unindented'.

\\[universal-argument] causes minimal indentation for the copied region.

A numeric prefix argument pads the minimal indent by PAD columns.

See also `my-copy-region-as-kill'."
  (interactive "P\nr")
  (if pad
      (progn
        (my-copy-region-unindented (if (consp pad) nil pad)
                                   beginning end)
        (delete-region beginning end))
    (kill-region beginning end)))


;; Supply a random fortune cookie as the *scratch* message.
(defvar my-fortune-map (make-sparse-keymap)
  "Keymap for `my-fortune-message'.")

(defun my-fortune-scratch-message ()
  "Supply a random fortune cookie."
  (interactive)
  (when-let*
      ((comment
        (and (executable-find "fortune")
             (with-temp-buffer
               (shell-command "fortune" t)
               (let ((comment-start ";;")
                     (comment-empty-lines t)
                     (tab-width 4)
                     (buf (current-buffer)))
                 (untabify (point-min) (point-max))
                 ;; Replace buffer contents with an unindented copy.
                 ;; FIXME: There are more buffers being used here
                 ;; (including in the unindent code) than I'd like.
                 (with-temp-buffer
                   (insert (with-current-buffer buf
                             (my-copy-region-unindented
                              0 (point-min) (point-max) #'buffer-string)))
                   (let ((buf2 (current-buffer)))
                     (set-buffer buf)
                     (replace-buffer-contents buf2)))
                 ;; Make it a comment.
                 (comment-region (point-min) (point-max)))
               (delete-trailing-whitespace (point-min) (point-max))
               (buffer-substring-no-properties (point-min) (1- (point-max))))))
       ;; Add keybindings.
       (fortune (concat (propertize comment 'keymap my-fortune-map)
                        "\n\n")))
    (if (called-interactively-p 'any)
        (insert fortune)
      fortune)))

;; Type "RET" to add another.
(define-key my-fortune-map (kbd "RET")
  (defalias (make-symbol "my-fortune-add")
    (lambda ()
      (interactive)
      (forward-paragraph)
      (if (looking-at "\n")
          (forward-char)
        (insert "\n"))
      (save-excursion
        (insert (my-fortune-scratch-message))))
    "Add another fortune."))

;; Type "g" to replace the current.
(define-key my-fortune-map (kbd "g")
  (defalias (make-symbol "my-fortune-replace")
    (lambda ()
      (interactive)
      (save-excursion
        (backward-paragraph)
        (when (looking-at "\n")
          (forward-line))
        (kill-paragraph 1)
        (when (looking-at "\n")
          (delete-char 1))
        (insert (my-fortune-scratch-message))))
    "Replace the current fortune."))

(defun my-fortune-set-initial-scratch-message ()
  "Set `initial-scratch-message' from `my-fortune-scratch-message'.

Used with `after-init-hook'."
  (let ((fortune (my-fortune-scratch-message)))
    (when fortune
      (setq initial-scratch-message fortune))))

(defun my-region-or-word (prompt)
  "Read a string from the minibuffer, prompting with PROMPT.
If `transient-mark-mode' is non-nil and the mark is active,
it defaults to the current region, else to the word at or before
point. This function returns a list (string) for use in `interactive'."
  (list (read-string prompt (or (and transient-mark-mode mark-active
                                     (buffer-substring-no-properties
                                      (region-beginning) (region-end)))
                                (current-word)))))

(defun my-hyphenate (beginning end)
  "Place hyphens between words in region."
  (interactive "*r")
  (save-excursion
    (goto-char beginning)
    (while (re-search-forward "[[:space:]\n]+" end :noerror)
      (replace-match "-"))))

(defcustom my-www-search-url
  "http://google.com/search?num=100&q=%s"
  "URL for WWW search, with %s placeholder for search string"
  :type 'string
  :group 'www)

(defalias 'my-render-url 'my-eww)
(eval-when-compile
  (defvar url-http-end-of-headers))
(defun my-eww (url)
  "Render URL as HTML."
  (declare (obsolete eww "24.4"))
  (interactive (progn (require 'browse-url)
                      (list (car (browse-url-interactive-arg "URL: ")))))
  (require 'shr)
  (url-retrieve
   url
   (lambda (&optional _status _cbargs)
     (let ((markup (current-buffer)))
       (delete-region (point-min) (1+ url-http-end-of-headers))
       (shr-render-buffer markup)
       (kill-buffer markup)))))

(defun my-browse-url-emacs (url)
  "Like `browse-url-emacs', but fast."
  (interactive (progn (require 'browse-url)
                      (list (car (browse-url-interactive-arg "URL: ")))))
  (url-retrieve
   url
   (lambda (&optional status _cbargs)
     (let ((error (plist-get status :error)))
       (if error
           (signal (car error) (cdr error))
         (delete-region (point-min) (1+ url-http-end-of-headers))
         (rename-buffer (file-name-nondirectory (url-filename
                                                 url-http-target-url))
                        t)
         ;; Set the appropriate major mode.  We set a local `buffer-file-name'
         ;; instead of using `url' to avoid triggering extra network activity
         ;; (either now or in future).
         (setq buffer-file-name (url-filename url-http-target-url))
         (normal-mode)
         ;; Allow killing the buffer despite it having an unsaved filename.
         (set-buffer-modified-p nil)
         ;; `url-http-generic-filter' is biting us by moving point *after* we've
         ;; finished, so we need to defer displaying the buffer until *after* we
         ;; have a change to rectify that :/
         (run-with-timer 0 nil (lambda (buf)
                                 (with-current-buffer buf
                                   (goto-char (point-min)))
                                 (pop-to-buffer buf))
                         (current-buffer)))))))

(defun my-www-search (string)
  "Ask a WWW browser to perform a web search for a given string.
Prompts for a string, defaulting to the active region or the current word at
or before point."
  (interactive (my-region-or-word "WWW search: "))
  (browse-url (format my-www-search-url (url-hexify-string string))))

(defcustom browse-url-palemoon-program "palemoon"
  "The name by which to invoke Palemoon."
  :type 'string
  :group 'browse-url)

(defcustom browse-url-palemoon-arguments nil
  "A list of strings to pass to Palemoon (or variant) as arguments."
  :type '(repeat (string :tag "Argument"))
  :group 'browse-url)

(defcustom browse-url-palemoon-new-window-is-tab nil
  "Whether to open up new windows in a tab or a new window.
If non-nil, then open the URL in a new tab rather than a new window if
`browse-url-palemoon' is asked to open it in a new window."
  :type 'boolean
  :group 'browse-url)

(defun browse-url-palemoon (url &optional new-window)
  "Ask the Palemoon WWW browser to load URL.
Defaults to the URL around or before point.  Passes the strings
in the variable `browse-url-palemoon-arguments' to Palemoon.

Interactively, if the variable `browse-url-new-window-flag' is non-nil,
loads the document in a new Palemoon window.  A non-nil prefix argument
reverses the effect of `browse-url-new-window-flag'.

If `browse-url-palemoon-new-window-is-tab' is non-nil, then
whenever a document would otherwise be loaded in a new window, it
is loaded in a new tab in an existing window instead.

Non-interactively, this uses the optional second argument NEW-WINDOW
instead of `browse-url-new-window-flag'."
  (interactive (browse-url-interactive-arg "URL: "))
  ;; `browse-url-maybe-new-window' is a macro.
  (eval-when-compile (require 'browse-url))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply 'start-process
           (concat "palemoon " url) nil
           browse-url-palemoon-program
           (append
            browse-url-palemoon-arguments
            (if (browse-url-maybe-new-window new-window)
                (if browse-url-palemoon-new-window-is-tab
                    '("-new-tab")
                  '("-new-window")))
            (list url)))))

(defvar my-ssh-history nil)
(defvar-local my-ssh-switches nil)
(put 'my-ssh-switches 'permanent-local t)
(defun my-ssh (args)
  "Connect to a remote host by SSH."
  ;; The following makes typing SPC a problem :/
  ;; (interactive
  ;;  (list (completing-read
  ;;         "ssh " my-ssh-history nil nil nil 'my-ssh-history)))
  (interactive
   (list (read-from-minibuffer "ssh " nil nil nil 'my-ssh-history)))
  (let* ((switches (split-string-and-unquote args))
         (name (concat "ssh " args))
         (termbuf (apply 'make-term name "ssh" nil switches)))
    (set-buffer termbuf)
    (setq-local my-ssh-switches switches)
    (term-mode)
    (term-char-mode)
    (switch-to-buffer termbuf)))

(defun my-terminal (delete-other-windows)
  "Switch to a `term' buffer (creating it if necessary)."
  (interactive "P")
  (require 'term)
  (unless (and term-ansi-buffer-name
               (buffer-name (get-buffer term-ansi-buffer-name))
               (get-buffer-process (get-buffer term-ansi-buffer-name)))
    (call-interactively 'ansi-term))
  (pop-to-buffer term-ansi-buffer-name '((display-buffer-reuse-window
                                          display-buffer-same-window)
                                         . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows))
  (setq-local term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

(defalias 'my-shell 'my-terminal)

(defun my-sql-console (delete-other-windows)
  "Switch to an interactive SQLi buffer (creating it if necessary)."
  (interactive "P")
  (require 'sql)
  (let ((sqlibuf
         (catch 'found
           (mapc (lambda (buf)
                   (with-current-buffer buf
                     (and (eq major-mode 'sql-interactive-mode)
                          (get-buffer-process buf)
                          (throw 'found buf))))
                 (buffer-list))
           nil)))
    (if sqlibuf
        (pop-to-buffer sqlibuf '((display-buffer-reuse-window
                                  display-buffer-same-window)
                                 . ((reusable-frames . visible))))
      (let ((current-prefix-arg '(4)))
        (let* ((sql-user
                (or (and (bound-and-true-p my-sql-db-user-getter)
                         (funcall my-sql-db-user-getter))
                    sql-user))
               (sql-database
                (or (and (bound-and-true-p my-sql-db-name-getter)
                         (funcall my-sql-db-name-getter))
                    sql-database)))
          (call-interactively 'sql-postgres)))))
  (when delete-other-windows
    (delete-other-windows)))

(defvar my-sql-query-buffer)

(defun my-sql-query-buffer (arg)
  "Open a `sql-mode' buffer which interacts with the current SQLi buffer.

Switches to an existing buffer if possible, otherwise creates a new buffer.

With C-u prefix arg, always creates a new buffer."
  (interactive "P")
  (let ((sqlibuf (current-buffer)))
    (if (null (sql-buffer-live-p sqlibuf))
        (error "Buffer %s is not a working SQLi buffer" sqlibuf)
      (let ((product sql-product)
            (querybuf
             (or (and (not (consp arg)) ;; prefix arg
                      (boundp 'my-sql-query-buffer)
                      (buffer-live-p (get-buffer my-sql-query-buffer))
                      (get-buffer my-sql-query-buffer))
                 (generate-new-buffer
                  (format "*SQL(CTL): %s*" (replace-regexp-in-string
                                           "\\*SQL: \\(.+\\)\\*" "\\1"
                                           (buffer-name sqlibuf)))))))
        (setq-local my-sql-query-buffer querybuf)
        (my-pop-to-buffer querybuf)
        (unless (eq major-mode 'sql-mode)
          (sql-mode)
          (setq sql-product product)
          (sql-highlight-product)
          (setq sql-buffer sqlibuf)
          (run-hooks 'sql-set-sqli-hook))))))

(defun my-drush-console (delete-other-windows)
  (interactive "P")
  (require 'drush-php)
  (unless (get-buffer-process (get-buffer "*Drush-PHP*"))
    (call-interactively 'run-drush-php))
  (pop-to-buffer "*Drush-PHP*" '((display-buffer-reuse-window
                                  display-buffer-same-window)
                                 . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows)))

(defvar my-terminal-run-history nil)
(defvar-local my-terminal-run-command nil)
(put 'my-terminal-run-command 'permanent-local t)
(defun my-terminal-run (command &optional name)
  "Runs COMMAND in a `term' buffer."
  (interactive
   (list (read-from-minibuffer "$ " nil nil nil 'my-terminal-run-history)))
  (let* ((name (or name command))
         (switches (split-string-and-unquote command))
         (command (pop switches))
         (termbuf (apply 'make-term name command nil switches)))
    (set-buffer termbuf)
    (setq-local my-terminal-run-command (cons command switches))
    (term-mode)
    (term-char-mode)
    (switch-to-buffer termbuf)))

(defvar watch-history nil)
(defun watch (command &optional name)
  "Runs \"watch COMMAND\" in a `term' buffer.  \"q\" to exit."
  (interactive
   (list (read-from-minibuffer "watch " nil nil nil 'watch-history)))
  (let* ((name (or name (concat "watch " command)))
         (switches (split-string-and-unquote command))
         (termbuf (apply 'make-term name "watch" nil switches))
         (proc (get-buffer-process termbuf)))
    (set-buffer termbuf)
    (term-mode)
    (term-char-mode)
    (setq show-trailing-whitespace nil)
    ;; Kill the process interactively with "q".
    (set-process-query-on-exit-flag proc nil)
    (let ((map (make-sparse-keymap))
          (cmdquit (make-symbol "watch-quit")))
      (put cmdquit 'function-documentation "Kill the `watch' buffer.")
      (put cmdquit 'interactive-form '(interactive))
      (fset cmdquit (apply-partially 'kill-process proc))
      (set-keymap-parent map (current-local-map))
      (define-key map (kbd "q") cmdquit)
      (use-local-map map))
    ;; Kill the buffer automatically when the process is killed.
    (set-process-sentinel
     proc (lambda (process _signal)
            (and (memq (process-status process) '(exit signal))
                 (buffer-live-p (process-buffer process))
                 (kill-buffer (process-buffer process)))))
    ;; Display the buffer.
    (switch-to-buffer termbuf)))

(defun my-pop-to-buffer (buf &optional delete-other-windows)
  "Switch to buffer BUF, and optionally maximise the window in its frame.
Re-use an existing window containing BUF (in a visible frame) by preference,
otherwise use the current selected window."
  (pop-to-buffer buf '(display-buffer-reuse-window
                       . ((reusable-frames . visible))))
  (when delete-other-windows
    (delete-other-windows)))

(defun my-ibuffer (arg)
  "Switch to ibuffer. Exit ibuffer, if current.

If ibuffer is already visible in another window, switch to that
window. If a prefix argument is supplied, we open ibuffer in the
current window even if another window is also displaying it."
  (interactive "P")
  (if (eq major-mode 'ibuffer-mode)
      (if (fboundp 'ibuffer-quit)
          (ibuffer-quit)
        (quit-window))
    (if arg
        (ibuffer)
      (let ((win (get-buffer-window "*Ibuffer*" (selected-frame))))
        (if (window-live-p win)
            (select-window win)
          (ibuffer))))))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value.

https://github.com/magnars/.emacs.d/blob/master/defuns/lisp-defuns.el"
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun my-eval-remote-library (url)
  "Retrieve and evaluate the code in the specified URL."
  (interactive "sURL: ")
  (save-window-excursion
    (eval-buffer
     (browse-url-emacs url))))

(defun my-toggle-fill-paragraph ()
  "Fill or unfill the current paragraph, depending upon the current line length.
When there is a text selection, act on the region.
See `fill-paragraph' and `fill-region'."
  (interactive)
  ;; We set a property 'currently-filled-p on this command's symbol
  ;; (i.e. on 'my-toggle-fill-paragraph), thus avoiding the need to
  ;; create a variable for remembering the current fill state.
  (save-excursion
    (let* ((deactivate-mark nil)
           (line-length (- (line-end-position) (line-beginning-position)))
           (currently-filled (if (eq last-command this-command)
                                 (get this-command 'currently-filled-p)
                               (< line-length fill-column)))
           (fill-column (if currently-filled
                            most-positive-fixnum
                          fill-column)))

      (if (region-active-p)
          (fill-region (region-beginning) (region-end))
        (fill-paragraph))

      (put this-command 'currently-filled-p (not currently-filled)))))

(defmacro with-temporary-advice (function class name &rest body)
  "Enable the specified advice, evaluate BODY, then disable the advice."
  `(unwind-protect
       (progn
         (ad-enable-advice ,function ,class ,name)
         (ad-activate ,function)
         ,@body)
     (ad-disable-advice ,function ,class ,name)
     (ad-activate ,function)))

(defun my-load-all-in-directory (dir &optional file-pattern)
  "`load' all elisp libraries in directory DIR which are not already loaded.

Optionally consider only filenames matching regexp FILE-PATTERN, which is
matched against each base filename (i.e. `file-name-nondirectory'). By default
all .el and .elc files are considered.

Note that the matching files are processed sans-extension, thus prioritising
and loading .elc files over .el files. So even if FILE-PATTERN matched only
the .el files, the .elc variants would be loaded instead, where present."
  (interactive "D")
  (let ((file-pattern (or file-pattern ".+\\.elc?$"))
        (libraries-loaded (mapcar #'file-name-sans-extension
                                  (delq nil (mapcar #'car load-history)))))
    (dolist (file (directory-files dir t file-pattern t))
      (let ((library (file-name-sans-extension file)))
        (unless (member library libraries-loaded)
          (load library)
          (push library libraries-loaded))))))

;; It's simpler without FILE-PATTERN:
;;
;; (defun my-load-all-in-directory (dir)
;;   "`load' all elisp libraries in directory DIR which are not already loaded."
;;   (interactive "D")
;;   (let ((libraries-loaded (mapcar #'file-name-sans-extension
;;                                   (delq nil (mapcar #'car load-history)))))
;;     (dolist (file (directory-files dir t ".+\\.elc?$" t))
;;       (let ((library (file-name-sans-extension file)))
;;         (unless (member library libraries-loaded)
;;           (load library)
;;           (push library libraries-loaded))))))

(defun my-copy-eterm-color-terminfo (hostspec)
  "Copy the eterm-color terminfo files to a remote host.
HOSTSPEC is a tramp host specification such as \"localhost\"
or \"user@example.com\""
  ;; http://stackoverflow.com/a/21006365/324105
  (interactive
   (let ((hosts (mapcar (lambda (x)
                          (cond ((stringp x) x)
                                ((null (car x)) (cadr x))
                                (t (concat (car x) "@" (cadr x)))))
                        (apply 'append
                               (mapcar
                                (lambda (x)
                                  (cl-remove-if-not 'identity
                                                    (apply (car x) (cdr x))))
                                (tramp-get-completion-function "ssh"))))))
     (list (completing-read "Hostname: " hosts nil 'confirm nil nil hosts nil))))
  (let ((destdir (format "/ssh:%s:~/.terminfo/e/" hostspec)))
    (unless (file-directory-p destdir)
      (dired-create-directory destdir))
    (copy-file (concat data-directory "e/eterm-color") destdir)
    (copy-file (concat data-directory "e/eterm-color.ti") destdir)))

(defun my-terminal-cursor-color (color)
  "Sets the terminal cursor colour by sending the appropriate escape sequence."
  (interactive
   (list (read-color "Color (white): " nil :allow-empty)))
  (when (string= color "")
    (setq color "white"))
  (send-string-to-terminal
   (concat "\033]12;" color "\007")))

(defvar my-emacs-uptime-log (locate-user-emacs-file "uptime.log")
  "Log file for `my-log-emacs-uptime'.")

(defun my-log-emacs-start-time ()
  "Write emacs start time to `my-emacs-uptime-log'.

If emacs doesn't get a chance to shut down cleanly, this may
still give me some idea of how long it was running for."
  (with-temp-buffer
    (insert (format "PID %d started at " (emacs-pid))
            (format-time-string "%Y-%m-%d %H:%M:%S" (current-time)) "\n")
    (append-to-file nil nil my-emacs-uptime-log)))

(defun my-log-emacs-uptime ()
  "Write emacs uptime to `my-emacs-uptime-log'. Use with `kill-emacs-hook'."
  (with-temp-buffer
    (insert (format-time-string "%Y-%m-%d %H:%M:%S" before-init-time) " to "
            (format-time-string "%Y-%m-%d %H:%M:%S" (current-time)) " = "
            (emacs-uptime) (format " (PID %d)\n" (emacs-pid)))
    (append-to-file nil nil my-emacs-uptime-log)))

(defun my-insert-kbd (keyseq)
  "Read key sequence, and insert it with <kbd> markup."
  (interactive "kType key sequence: ")
  (insert "<kbd>"
          (mapconcat (lambda (s)
                       (replace-regexp-in-string "<" "&lt;" s))
                     (split-string (help-key-description keyseq nil))
                     "</kbd><kbd>")
          "</kbd>"))

;; I bind `apropos-do-all' non-nil by default, so these commands act
;; as replacements for `apropos-command' and `apropos-user-option' and
;; ensure that only commands and user options are displayed.

(defvar apropos-do-all)
(defun my-apropos-command (pattern)
  "Show commands (interactively callable functions) that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words."
  (interactive (list (apropos-read-pattern "command")))
  (let ((apropos-do-all nil))
    (apropos-command pattern)))

(defun my-apropos-user-option (pattern)
  "Show user options that match PATTERN.
PATTERN can be a word, a list of words (separated by spaces),
or a regexp (using some regexp special characters).  If it is a word,
search for matches for that word as a substring.  If it is a list of words,
search for matches for any two (or more) of those words."
  (interactive (list (apropos-read-pattern "user option")))
  (let ((apropos-do-all nil))
    (apropos-user-option pattern)))

;; Testing the modification timestamp for a file or directory
;; (directory tree version finds the latest mtime for any child)

(defun my-buffer-file-last-modified (file-name)
  "Return a timestamp for the most recent modification to the specified file.
We assume that a buffer is visiting the most recent version of this time."
  (let ((buffer (get-file-buffer file-name)))
    (when buffer
      (string-to-number
       (format-time-string
        "%s" (with-current-buffer (get-file-buffer file-name)
               (visited-file-modtime)))))))

(defun my-directory-tree-last-modified (dir)
  "Return a timestamp for the most recent modification under the specified dir."
  (string-to-number
   (shell-command-to-string
    (format
     (concat
      " max=0; find %s -print0"; dir
      " | xargs -0 stat --format=%%Y"
      " | while read -r ts; do test $ts -gt $max && max=$ts && echo $max; done"
      " | tail -1")
     (shell-quote-argument dir)))))

(defun my-trace-package (prefix)
  "Trace all functions which start with PREFIX.
For example, to trace all ELP functions, do the following:

    \\[my-trace-package] RET elp- RET"
  (interactive ;; derived from `elp-instrument-package'.
   (list (completing-read "Prefix of package to trace: "
                          obarray 'my-traceable-p)))
  (if (zerop (length prefix))
      (error "Tracing all Emacs functions would render Emacs unusable"))
  (mapc (lambda (name)
          (trace-function-foreground (intern name)))
        (all-completions prefix obarray 'my-traceable-p))
  (message "Use %s to cease tracing."
           (substitute-command-keys "\\[untrace-all]")))

(defun my-traceable-p (fun)
  "Predicate for `my-trace-package'."
  ;; Derived from `elp-profilable-p'. Fewer restrictions are needed here.
  (and (symbolp fun)
       (fboundp fun)
       (not (keymapp fun))))

(defun password-composer (domain)
  "Run password-composer."
  (interactive "sDomain: ")
  (let ((buf (make-comint-in-buffer
              "password-composer" nil "password-composer" nil domain)))
    (set-buffer buf)
    (setq comint-process-echoes nil)
    (pop-to-buffer buf)
    (comint-send-invisible "Password: ")
    (use-local-map
     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map (current-local-map))
       (define-key map "q" `(lambda () (interactive) (kill-buffer ,buf)))
       map))))

(defun my-x-paste (command wid &optional bufname header text)
  "Run COMMAND and paste the result into the original X window.

\(For use with programs where \"C-v\" is paste.)

The value returned from COMMAND will be set in the system clipboard,
and then the key \"C-v\" will be performed in the original X window.

The pop-up frame will initially display a temporary buffer named
BUFNAME which is displaying the `header-line-format' HEADER, and
buffer contents TEXT.  You can use these to give the user context
for the interaction.

Requires that \"xdotool\" is installed on your system.  E.g.:

 sudo apt-get install xdotool

To use, trigger the following command via your window manager:

 emacsclient --eval \"(my-x-paste-COMMAND $(xdotool getactivewindow))\"

With \(my-x-paste-COMMAND wid) being a wrapper for calling `my-x-paste'.

Example:

 \(defun my-x-paste-totp (wid)
   \"Paste `totp-as-clipboard' into X window WID (see `my-x-paste').\"
   (interactive)
   (my-x-paste #\\='totp-as-clipboard wid \"*TOTP\"
               \"Time-based One-time Password (TOTP)\"))

XMonad key binding (mod-T) for xmonad.hs:

 , ((modMask .|. shiftMask, xK_t), spawn \"emacsclient --eval \\
 \\\"(my-x-paste-totp $(xdotool getactivewindow))\\\"\")

Also for XMonad, include the following in your manageHook to make the
pop-up frame float over the other windows rather than being tiled:

 appName =? \"EmacsXPaste\" --> doFloat"
  (interactive)
  (with-temp-buffer
    (when bufname
      (rename-buffer bufname :unique))
    (when header
      (setq-local header-line-format header))
    (when text
      (insert text))
    (let* ((buf (current-buffer))
           (width 80)
           (height (max window-safe-min-height
                        (count-lines (point-min) (point-max))))
           (pxwidth (+ 3 (* width (default-font-width))))
           (pxheight (+ 3 (* height (default-font-height))))
           (fparams `((my-x-paste . t)
                      (name . "EmacsXPaste")
                      (fullscreen . nil)
                      (width . ,width)
                      (height . ,height)
                      (left . ,(- (/ (display-pixel-width) 2) (/ pxwidth 2)))
                      (top . ,(- (/ (display-pixel-height) 2) (/ pxheight 2)))
                      (menu-bar-lines . 0)
                      (tool-bar-lines . 0)
                      (auto-raise . t))))
      (select-frame (make-frame fparams))
      (pop-to-buffer buf)
      (delete-other-windows)
      (unwind-protect
          (let ((value (call-interactively command)))
            (and value
                 (integerp wid)
                 (gui-backend-set-selection 'CLIPBOARD value)
                 (call-process "xdotool" nil nil nil
                               "key"
                               "--clearmodifiers"
                               "--window" (number-to-string wid)
                               "ctrl+v")
                 t))
        ;; We need to give the target window time to talk to the Emacs frame to
        ;; extract the clipboard text before the frame is deleted.  This should
        ;; only take a moment; but as we don't know for sure how long we need, we
        ;; make the frame invisible and then sleep for a full second.  Note that
        ;; we need to redisplay to activate the visibility change.
        (set-frame-parameter (selected-frame) 'visibility nil)
        (redisplay)
        (sleep-for 1)
        (delete-frame)))))

(defun my-passwd-read-insert-dots ()
  "`read-passwd' and insert in buffer using dots for display replacement."
  (interactive)
  (let ((pass (read-passwd "password: ")))
    (insert (propertize pass 'display (make-string (length pass) ?.)))))

(defvar domain-hash-history nil
  "Domain history for `domain-hash-arguments'.")
(defvar domain-hash-algorithm 'sha256
  "Any valid `secure-hash' algorithm.")
(defvar domain-hash-length nil
  "The length of substring returned by `domain-hash'.
nil to return the complete hash.")

(defun domain-hash-arguments (&optional algorithm)
  "Obtain interactive arguments for `domain-hash' and friends."
  (let ((args
         (list (let ((default (car domain-hash-history)))
                 (read-string (if default
                                  (format "Domain (%s): " default)
                                "Domain: ")
                              nil 'domain-hash-history default))
               (read-passwd "Passphrase: ")
               current-prefix-arg)))
    (if algorithm
        (append args (list (intern (completing-read
                                    (if domain-hash-algorithm
                                        (format "Algorithm (%s): "
                                                domain-hash-algorithm)
                                      "Algorithm: ")
                                    (secure-hash-algorithms)
                                    nil t nil nil (symbol-name
                                                   domain-hash-algorithm)))))
      args)))

(defun domain-hash (domain passphrase &optional kill algorithm)
  "Hash a PASSPHRASE:DOMAIN combination.

With prefix-arg copies hash to kill-ring, otherwise inserts it."
  (interactive (domain-hash-arguments t))
  (let* ((hash (substring-no-properties
                (secure-hash (or algorithm domain-hash-algorithm)
                             (concat passphrase ":" domain))
                0 domain-hash-length))
         (dots (propertize hash 'display (make-string (length hash) ?.))))
    (if kill
        (cond ((eq kill :clipboard)
               ;; Why doesn't this work?:
               ;; (let ((select-enable-clipboard t))
               ;;   (gui-select-text dots)))
               (gui-backend-set-selection 'CLIPBOARD dots))
              (t
               (kill-new dots)))
      (insert dots))
    ;; Return the hash value.
    dots))

(defun domain-hash-md5 (domain passphrase &optional kill)
  "`domain-hash' using the md5 algorithm."
  (interactive (domain-hash-arguments))
  (let ((domain-hash-algorithm 'md5)
        (domain-hash-length 8))
    (domain-hash domain passphrase kill)))

(defun domain-hash-md5-as-kill (domain passphrase &optional _kill)
  (interactive (domain-hash-arguments))
  (domain-hash-md5 domain passphrase :kill))

(defun domain-hash-md5-as-clipboard (domain passphrase &optional _kill)
  (interactive (domain-hash-arguments))
  (domain-hash-md5 domain passphrase :clipboard))

(defun my-x-paste-domain-hash-md5 (wid)
  "Paste `domain-hash-md5-as-kill' into X window WID (see `my-x-paste')."
  (interactive)
  (my-x-paste #'domain-hash-md5-as-clipboard wid "*passphrase*"
              "Domain passphrase"))

(defun my-x-paste-totp (wid)
  "Paste `totp-as-clipboard' into X window WID (see `my-x-paste')."
  (interactive)
  (my-x-paste #'totp-as-clipboard wid "*TOTP"
              "Time-based One-time Password (TOTP)"))

(defun my-crontab-edit ()
  "Edit crontab."
  (interactive)
  (require 'with-editor)
  (with-editor-async-shell-command "crontab -e"))

;; https://fuco1.github.io/2017-05-06-Enhanced-beginning--and-end-of-buffer-in-special-mode-buffers-%28dired-etc.%29.html

(defmacro my-special-buffer-pos (library fname doc pos remap mode &rest forms)
  "Helper for `my-define-bob' and `my-define-eob'."
  (let ((modename (symbol-name mode)))
    (let (;;(fname (intern (concat "my-" modename "-" (symbol-name remap))))
          (modemap (intern (concat modename "-map")))
          ;; (modehook (intern (concat modename "-hook")))
          )
      `(progn
         (defalias ',fname
           (lambda ()
             (interactive)
             (let ((p (point)))
               (goto-char (,pos))
               ,@forms
               (when (= p (point))
                 (goto-char (,pos)))))
           ,doc)
         (eval-after-load ,library
           '(progn
              (defvar ,modemap) ;; Silence compiler warnings.
              (define-key ,modemap [remap ,remap] #',fname)))))))

(defmacro my-define-bob (fname mode library &rest forms)
  "Define a special version of `beginning-of-buffer' in MODE.

The special function is defined such that the point first moves
to `point-min' and then FORMS are evaluated.  If the point did
not change because of the evaluation of FORMS, jump
unconditionally to `point-min'.  This way repeated invocations
toggle between real beginning and logical beginning of the
buffer."
  (declare (indent 3))
  (let ((doc "Toggle between the logical and real beginning of the buffer."))
    `(my-special-buffer-pos
      ,library ,fname ,doc point-min beginning-of-buffer ,mode ,@forms)))

(defmacro my-define-eob (fname mode library &rest forms)
  "Define a special version of `end-of-buffer' in MODE.

The special function is defined such that the point first moves
to `point-max' and then FORMS are evaluated.  If the point did
not change because of the evaluation of FORMS, jump
unconditionally to `point-max'.  This way repeated invocations
toggle between real end and logical end of the buffer."
  (declare (indent 3))
  (let ((doc "Toggle between the logical and real end of the buffer."))
    `(my-special-buffer-pos
      ,library ,fname ,doc point-max end-of-buffer ,mode ,@forms)))

;; Awkwardly, `find-function' will find these definitions only when
;; the regexp "^([^ ]+ FUNCTION-NAME" can be found, which places
;; several constraints upon how we define these functions (including
;; being needing to pass the library name, as we are not able to wrap
;; the definitions themselves in eval-after-load due to indentation).
;; See `find-function-search-for-symbol'.
;;
;; `find-function-regexp-alist' can solve this, I suspect? Argh,
;; except `find-function-noselect' passes `nil' for TYPE which means
;; that `find-function-regexp' is always used, so I would need to
;; modify that. (Can't we have a symbol property to specify the type?)
;;
;; diff -u lisp/emacs-lisp/find-func.el.gz
;; --- /usr/local/share/emacs/25.2/lisp/emacs-lisp/find-func.el.gz
;; +++ #<buffer find-func.el.gz>
;; @@ -301,6 +301,8 @@
;;  The search is done in the source for library LIBRARY."
;;    (if (null library)
;;        (error "Don't know where `%s' is defined" symbol))
;; +  (unless type
;; +    (setq type (get symbol 'find-function-type)))
;;    ;; Some functions are defined as part of the construct
;;    ;; that defines something else.
;;    (while (and (symbolp symbol) (get symbol 'definition-name))
;;
;; Diff finished.  Tue May  9 18:09:11 2017

;; Alternatively (additionally?) `elisp-xref-find-def-functions' can
;; presumably make these findable without such constraints.  I would
;; need to ensure that I actually use xref, though.

(defvar my-find-special-buffer-pos-regexp
  "^\\s-*(my-define-[be]ob %s\\_>"
  "Used in `find-function-regexp-alist' for finding definitions.")

(with-eval-after-load "find-func"
  (add-to-list 'find-function-regexp-alist
               '(my-special-buffer-pos . my-find-special-buffer-pos-regexp)
               :append))

;; Silence compiler warnings
(eval-when-compile
  (declare-function bs-down "bs")
  (declare-function bs-up "bs")
  (declare-function compilation-next-error "compile")
  (declare-function compilation-previous-error "compile")
  (declare-function dired-get-filename "dired")
  (declare-function dired-next-line "dired")
  (declare-function dired-previous-line "dired")
  (declare-function ibuffer-backward-line "ibuffer")
  (declare-function ibuffer-forward-line "ibuffer")
  (declare-function my-dired-beginning-of-buffer "my-utilities")
  (declare-function my-dired-end-of-buffer "my-utilities")
  (declare-function occur-next "replace")
  (declare-function occur-prev "replace")
  (declare-function org-agenda-next-item "org-agenda")
  (declare-function org-agenda-previous-item "org-agenda")
  (declare-function vc-dir-next-line "vc-dir")
  (declare-function vc-dir-previous-line "vc-dir")
  )

;; Dired (M-x dired)
(with-eval-after-load "dired"
  (my-define-bob my-dired-beginning-of-buffer
      dired-mode "dired"
    (while (not (ignore-errors (dired-get-filename)))
      (dired-next-line 1)))
  (my-define-eob my-dired-end-of-buffer
      dired-mode "dired"
    (dired-previous-line 1)))

;; Occur (M-x occur)
(my-define-bob my-occur-beginning-of-buffer
    occur-mode "replace"
  (occur-next 1))
(my-define-eob my-occur-end-of-buffer
    occur-mode "replace"
  (occur-prev 1))

;; Ibuffer (M-x ibuffer)
(my-define-bob my-ibuffer-beginning-of-buffer
    ibuffer-mode "ibuffer"
  (ibuffer-forward-line 1))
(my-define-eob my-ibuffer-end-of-buffer
    ibuffer-mode "ibuffer"
  (ibuffer-backward-line 1))

;; Org Agenda (M-x org-agenda)
(my-define-bob my-org-agenda-beginning-of-buffer
    org-agenda-mode "org-agenda"
  (org-agenda-next-item 1))
(my-define-eob my-org-agenda-end-of-buffer
    org-agenda-mode "org-agenda"
  (org-agenda-previous-item 1))

;; grep, rgrep, etc...
(my-define-bob my-grep-beginning-of-buffer
    grep-mode "grep"
  (compilation-next-error 1))
(my-define-eob my-grep-end-of-buffer
    grep-mode "grep"
  (compilation-previous-error 1))

;; vc directory view (M-x vc-dir or C-x v d)
(my-define-bob my-vc-dir-beginning-of-buffer
    vc-dir-mode "vc-dir"
  (vc-dir-next-line 1))
(my-define-eob my-vc-dir-end-of-buffer
    vc-dir-mode "vc-dir"
  (vc-dir-previous-line 1))

;; bs (M-x bs-show)
(my-define-bob my-bs-beginning-of-buffer
    bs-mode "bs"
  (bs-down 2))
(my-define-eob my-bs-end-of-buffer
    bs-mode "bs"
  (bs-up 1)
  (bs-down 1))

;; Recentf (M-x recentf-open-files)
(my-define-bob my-recentf-dialog-beginning-of-buffer
    recentf-dialog-mode "recentf"
  (when (re-search-forward "^  \\[" nil t)
    (goto-char (match-beginning 0))))
(my-define-eob my-recentf-dialog-end-of-buffer
    recentf-dialog-mode "recentf"
  (re-search-backward "^  \\[" nil t))

(defmacro loop-collect (item &rest loop)
  "Emulate list comprehension syntax/order for `cl-loop'.

\(loop-collect x for x in ...) => (cl-loop for x in ... collect x)"
  (require 'cl-macs)
  `(cl-loop ,@loop collect ,item))


;; Make "M-g [1-9] ... RET" a shortcut for "M-g g [1-9] ... RET"
;; (dotimes (n 9)
;;   (global-set-key (kbd (format "M-g %s" (1+ n))) #'my-goto-line))
(defun my-goto-line ()
  "Slightly faster `goto-line'."
  (interactive)
  (when (and (>= last-command-event ?1)
             (<= last-command-event ?9)
             (not (numberp current-prefix-arg)))
    (push last-command-event unread-command-events))
  (call-interactively #'goto-line))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'my-utilities)

;;; Local Variables:
;;; eval:(outline-minor-mode 1)
;;; End:
